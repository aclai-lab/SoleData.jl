var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleData","category":"page"},{"location":"#SoleData","page":"Home","title":"SoleData","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleData.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Logical-foundations","page":"Home","title":"Logical foundations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here are some core concepts for symbolic artificial intelligence with propositional and modal logics.o","category":"page"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.Atom\nSoleLogics.AbstractWorld\nSoleLogics.Interval\nSoleLogics.Interval2D\nSoleLogics.syntaxstring\nSoleLogics.IA_L\nSoleLogics.AbstractFrame\nSoleLogics.accessibles\nminify","category":"page"},{"location":"#SoleLogics.Atom","page":"Home","title":"SoleLogics.Atom","text":"struct Atom{V} <: AbstractAtom\n    value::V\nend\n\nSimplest atom implementation, wrapping a value.\n\nSee also AbstractAtom, value, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractWorld","page":"Home","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Interval","page":"Home","title":"SoleLogics.Interval","text":"struct Interval{T<:Real} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Interval2D","page":"Home","title":"SoleLogics.Interval2D","text":"struct Interval2D{T<:Real} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.syntaxstring","page":"Home","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including the kwargs... part!) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.IA_L","page":"Home","title":"SoleLogics.IA_L","text":"See IntervalRelation.\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.AbstractFrame","page":"Home","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures. A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.accessibles","page":"Home","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\naccessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,), Interval{Int});\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator to worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator to parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{<:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"function"},{"location":"#SoleData.minify","page":"Home","title":"SoleData.minify","text":"minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}\n\nReturn a minified version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.\n\nSee also isminifiable.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"See SoleLogics for more.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ontop of the logical layer, we define features, conditions on features, logisets, and memosets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"types/features.jl\", \"types/conditions.jl\", \"types/logiset.jl\", \"types/memoset.jl\"]","category":"page"},{"location":"#SoleData.AbstractFeature","page":"Home","title":"SoleData.AbstractFeature","text":"abstract type AbstractFeature end\n\nAbstract type for features of worlds of [Kripke structures](https://en.wikipedia.org/wiki/Kripkestructure(model_checking).\n\nSee also VarFeature, featvaltype, SoleLogics.AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.parsefeature-Tuple{Type{<:AbstractFeature}, AbstractString}","page":"Home","title":"SoleData.parsefeature","text":"parsefeature(FT::Type{<:AbstractFeature}, expr::AbstractString; kwargs...)\n\nParse a feature of type FT from its syntaxstring representation. Depending on FT, specifying keyword arguments such as featvaltype::Type may be required or recommended.\n\nSee also parsecondition.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.AbstractCondition","page":"Home","title":"SoleData.AbstractCondition","text":"abstract type AbstractCondition{FT<:AbstractFeature} end\n\nAbstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a logical dataset. In logical contexts, these are wrapped into Atoms.\n\nSee also Atom, syntaxstring, ScalarMetaCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.checkcondition-Tuple{SoleData.AbstractCondition, Vararg{Any}}","page":"Home","title":"SoleData.checkcondition","text":"checkcondition(c::AbstractCondition, args...; kwargs...)\n\nCheck a condition (e.g., on a world of a logiset instance).\n\nThis function must be implemented for each subtype of AbstractCondition.\n\nExamples\n\n# Checking a condition on a logiset created from a DataFrame\nusing SoleData, DataFrames\n\n# Load the iris dataset\niris_df = DataFrame(load_iris());\n\n# Convert the DataFrame to a logiset\niris_logiset = scalarlogiset(iris_df);\n\n# Create a ScalarCondition\ncondition = ScalarCondition(:sepal_length, >, 5.0);\n\n# Check the condition on the logiset\n@assert checkcondition(condition, iris_logiset, 1) == true\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.parsecondition-Tuple{Type{<:SoleData.AbstractCondition}, AbstractString}","page":"Home","title":"SoleData.parsecondition","text":"parsecondition(C::Type{<:AbstractCondition}, expr::AbstractString; kwargs...)\n\nParse a condition of type C from its syntaxstring representation. Depending on C, specifying keyword arguments such as featuretype::Type{<:AbstractFeature}, and featvaltype::Type may be required or recommended.\n\nSee also parsefeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.AbstractLogiset","page":"Home","title":"SoleData.AbstractLogiset","text":"abstract type AbstractLogiset <: AbstractInterpretationSet end\n\nAbstract type for logisets, that is, sets of logical interpretations onto which (formulas on) conditions can be checked.\n\nSee also AbstractCondition, AbstractFeature, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.features-Tuple{SoleData.AbstractLogiset}","page":"Home","title":"SoleData.features","text":"Return the number of features for which instances in a logiset have value. Note that the set of features is not always defined for all logiset types.\n\nSee also AbstractLogiset, featvalue.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.nfeatures-Tuple{SoleData.AbstractLogiset}","page":"Home","title":"SoleData.nfeatures","text":"Return the number of features in a logiset (if defined).\n\nSee also features.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.AbstractFullMemoset","page":"Home","title":"SoleData.AbstractFullMemoset","text":"Abstract type for full memoization structures for checking generic formulas.\n\nThese structures can be stacked and coupled with one-step memoization structures (see SupportedLogiset).\n\nSee AbstractOneStepMemoset, FullMemoset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractMemoset","page":"Home","title":"SoleData.AbstractMemoset","text":"abstract type AbstractMemoset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame,\n} <: AbstractModalLogiset{W,U,FT,FR} end\n\nAbstract type for memoization structures to be used when checking formulas on logisets.\n\nSee also FullMemoset, SupportedLogiset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractOneStepMemoset","page":"Home","title":"SoleData.AbstractOneStepMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩p; with these formulas, so-called \"one-step\" optimizations can be performed.\n\nThese structures can be stacked and coupled with full memoization structures (see SupportedLogiset).\n\nSee ScalarOneStepMemoset, AbstractFullMemoset, representatives.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.capacity-Tuple{SoleData.AbstractMemoset}","page":"Home","title":"SoleData.capacity","text":"Return the capacity of a memoset, that is, the number of memoizable values (if finite).\n\nSee also AbstractMemoset.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.nmemoizedvalues-Tuple{SoleData.AbstractMemoset}","page":"Home","title":"SoleData.nmemoizedvalues","text":"Return the number of memoized values in a memoset.\n\nSee also AbstractMemoset.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"AbstractModalLogiset\nAbstractScalarOneStepRelationalMemoset","category":"page"},{"location":"#SoleData.AbstractModalLogiset","page":"Home","title":"SoleData.AbstractModalLogiset","text":"abstract type AbstractModalLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractLogiset end\n\nAbstract type for logisets, that is, logical datasets for symbolic learning where each instance is a Kripke structure associating feature values to each world. Conditions (see AbstractCondition), and logical formulas with conditional letters can be checked on worlds of instances of the dataset.\n\nInterface\n\nreadfeature(X::AbstractModalLogiset, featchannel::Any, w::W, feature::AbstractFeature)\nfeatchannel(X::AbstractModalLogiset, i_instance::Integer, feature::AbstractFeature)\nfeatvalue(feature::AbstractFeature, X::AbstractModalLogiset, i_instance::Integer, args...; kwargs...)\nfeatvalue!(feature::AbstractFeature, X::AbstractModalLogiset{W}, featval, i_instance::Integer, w::W)\nfeatvalues!(feature::AbstractFeature, X::AbstractModalLogiset{W}, featslice)\nframetype(X::AbstractModalLogiset)\nworldtype(X::AbstractModalLogiset)\n\nSee also AbstractCondition, AbstractFeature, SoleLogics.AbstractKripkeStructure, SoleLogics.AbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractScalarOneStepRelationalMemoset","page":"Home","title":"SoleData.AbstractScalarOneStepRelationalMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩ (f ⋈ t), for a generic relation R that is not the global relation (SoleLogics.globalrel). We refer to these structures as relational memosets.\n\n\n\n\n\n","category":"type"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"#Logisets","page":"Home","title":"Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"utils/features.jl\", \"utils/conditions.jl\"]","category":"page"},{"location":"#SoleData.ExplicitFeature","page":"Home","title":"SoleData.ExplicitFeature","text":"struct ExplicitFeature{T} <: AbstractFeature\n    name::String\n    featstruct\nend\n\nA feature encoded explicitly, for example, as a slice of DimensionalDatasets.UniformFullDimensionalLogiset's feature structure.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.Feature","page":"Home","title":"SoleData.Feature","text":"struct Feature{A} <: AbstractFeature\n    atom::A\nend\n\nA feature solely identified by an atom (e.g., a string with its name, a tuple of strings, etc.)\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.FunctionalCondition","page":"Home","title":"SoleData.FunctionalCondition","text":"struct FunctionalCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\n    f::FT\nend\n\nA condition which yields a truth value equal to the value of a function.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ValueCondition","page":"Home","title":"SoleData.ValueCondition","text":"struct ValueCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\nend\n\nA condition which yields a truth value equal to the value of a feature.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"utils/logiset.jl\", \"utils/modal-logiset.jl\"]","category":"page"},{"location":"#SoleData.ExplicitBooleanModalLogiset","page":"Home","title":"SoleData.ExplicitBooleanModalLogiset","text":"struct ExplicitBooleanModalLogiset{\n    W<:AbstractWorld,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractModalLogiset{W,Bool,FT,FR}\n\n    d :: Vector{Tuple{Dict{W,Vector{FT}},FR}}\n\nend\n\nA logiset where the features are boolean, and where each instance associates to each world the set of features with true.\n\nSee also AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ExplicitModalLogiset","page":"Home","title":"SoleData.ExplicitModalLogiset","text":"struct ExplicitModalLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractModalLogiset{W,U,FT,FR}\n\n    d :: Vector{Tuple{Dict{W,Dict{FT,U}},FR}}\n\nend\n\nA logiset where the features are boolean, and where each instance associates to each world the set of features with true.\n\nSee also AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"utils/memoset.jl\"]","category":"page"},{"location":"#SoleData.FullMemoset","page":"Home","title":"SoleData.FullMemoset","text":"A generic, full memoization structure that works for any crisp logic; For each instance of a dataset, this structure associates formulas to the set of worlds where the formula holds; it was introduced by Emerson-Clarke for the well-known model checking algorithm for CTL*.\n\nSee also SupportedLogiset, AbstractMemoset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"ScalarOneStepMemoset","category":"page"},{"location":"#SoleData.ScalarOneStepMemoset","page":"Home","title":"SoleData.ScalarOneStepMemoset","text":"One-step memoization structures for optimized check of formulas of type ⟨R⟩p, where p wraps a scalar condition, such as MyFeature ≥ 10. With such formulas, scalar one-step optimization can be performed.\n\nFor example, checking ⟨R⟩(MyFeature ≥ 10) on a world w of a Kripke structure involves comparing the maximum MyFeature across ws accessible worlds with 10; but the same maximum value can be reused to check sibling formulas such as ⟨R⟩(MyFeature ≥ 100). This sparks the idea of storing and reusing scalar aggregations (e.g., minimum/maximum) over the feature values. Each value refers to a specific world, and an object of type ⟨R⟩(f ⋈ ?), called a \"scalar metacondition\".\n\nSimilar cases arise depending on the relation and the test operator (or, better, its aggregator), and further optimizations can be applied for specific feature types (see representatives).\n\nAn immediate special case, however, arises when R is the global relation G since, in such case, a single aggregate value is enough for all worlds within the Kripke structure. Therefore, we differentiate between generic, relational memosets (see AbstractScalarOneStepRelationalMemoset), and global memosets (see AbstractScalarOneStepGlobalMemoset), which are usually much smaller.\n\nGiven a logiset X, a ScalarOneStepMemoset covers a set of relations and metaconditions, and it holds both a relational and a global memoset. It can be instantiated via:\n\nScalarOneStepMemoset(\n    X                       :: AbstractModalLogiset{W,U},\n    metaconditions          :: AbstractVector{<:ScalarMetaCondition},\n    relations               :: AbstractVector{<:AbstractRelation};\n    precompute_globmemoset  :: Bool = true,\n    precompute_relmemoset   :: Bool = false,\n    print_progress          :: Bool = false,\n)\n\nIf precompute_relmemoset is false, then the relational memoset is simply initialized as an empty structure, and memoization is performed on it upon checking formulas. precompute_globmemoset works similarly.\n\nSee SupportedLogiset, ScalarMetaCondition, AbstractOneStepMemoset.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"utils/supported-logiset.jl\"]","category":"page"},{"location":"#SoleData.SupportedLogiset","page":"Home","title":"SoleData.SupportedLogiset","text":"A logiset, associated to a number of cascading full or one-step memoization structures, that are used for optimizing the checking of formulas.\n\nSee also SupportedLogiset, AbstractFullMemoset, AbstractOneStepMemoset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"check.jl\"]","category":"page"},{"location":"#SoleLogics.check-Union{Tuple{FT}, Tuple{U}, Tuple{W}, Tuple{SyntaxTree, SoleLogics.LogicalInstance{<:SoleData.AbstractModalLogiset{W, var\"#s69\", FT, FR} where {var\"#s69\"<:U, FT<:AbstractFeature, FR<:SoleLogics.AbstractFrame{W}}}}, Tuple{SyntaxTree, SoleLogics.LogicalInstance{<:SoleData.AbstractModalLogiset{W, var\"#s71\", FT, FR} where {var\"#s71\"<:U, FT<:AbstractFeature, FR<:SoleLogics.AbstractFrame{W}}}, Union{Nothing, SoleLogics.AnyWorld, AbstractWorld}}} where {W<:AbstractWorld, U, FT<:Formula}","page":"Home","title":"SoleLogics.check","text":"check(\n    φ::SoleLogics.SyntaxTree,\n    i::SoleLogics.LogicalInstance{<:AbstractModalLogiset{W,<:U}},\n    w::Union{Nothing,AnyWorld,<:AbstractWorld} = nothing;\n    kwargs...\n)::Bool\n\nCheck whether a formula φ holds for a given instance i_instance of a logiset X, on a world w. Note that the world can be elided for grounded formulas (see isgrounded).\n\nThis implementation recursively evaluates the subformulas of φ and use memoization to store the results using Emerson-Clarke algorithm. The memoization structure is either the one stored in X itself (if X supports memoization) or a structure passed as the use_memo argument. If X supports onestep memoization, then it will be used for specific diamond formulas, up to an height equal to a keyword argument memo_max_height.\n\nArguments\n\nφ::SoleLogics.SyntaxTree: the formula to check.\ni::SoleLogics.LogicalInstance{<:AbstractModalLogiset{W,<:U}}: the instance of the logiset to check in.\nw::Union{Nothing,AnyWorld,<:AbstractWorld} = nothing: the world to check in. If nothing, the method checks in all worlds of the instance.\n\nKeyword arguments\n\nuse_memo::Union{Nothing,AbstractMemoset{<:AbstractWorld},AbstractVector{<:AbstractDict{<:FT,<:AbstractWorlds}}} = nothing: the memoization structure to use. If nothing, the method uses the one stored in X if X supports memoization. If AbstractMemoset, the method uses the i_instance-th element of the memoization structure. If AbstractVector, the method uses the i_instance-th element of the vector.\nperform_normalization::Bool = true: whether to normalize the formula before checking it.\nmemo_max_height::Union{Nothing,Int} = nothing: the maximum height up to which onestep memoization should be used. If nothing, the method does not use onestep memoization.\nonestep_memoset_is_complete = false: whether the onestep memoization structure is complete (i.e. it contains all possible values of the metaconditions in the structure).\n\n\n\n\n\n","category":"method"},{"location":"#Scalar-Logisets","page":"Home","title":"Scalar Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\n\t\"scalar/main.jl\",\n\t\"scalar/scalarformula.jl\",\n\t\"scalar/var-features.jl\",\n\t\"scalar/test-operators.jl\",\n\t\"scalar/conditions.jl\",\n\t\"scalar/templated-formulas.jl\",\n\t\"scalar/random.jl\",\n\t\"scalar/logiseed.jl\",\n\t\"scalar/scalarlogiset.jl\",\n\t\"scalar/autologiset-tools.jl\",\n\t\"scalar/memosets.jl\",\n\t\"scalar/onestep-memoset.jl\",\n\t\"scalar/propositional-logiset.jl\",\n\t\"scalar/propositional-formula-simplification.jl\",\n]","category":"page"},{"location":"#SoleData.MixedCondition","page":"Home","title":"SoleData.MixedCondition","text":"A union type for all condition-inducing objects. An object of this type, coupled with a (e.g., dimensional) dataset will induce a set of conditions in scalarlogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.@scalarformula-Tuple{Any}","page":"Home","title":"SoleData.@scalarformula","text":"@scalarformula expr\n\nParse a logical formula on scalar conditions, such as V1 > 10. Note that logical operators take precedence over comparison operators, so it is often the case that expressions such as V1 > 10 must be wrapped in parentheses.\n\nExamples\n\njulia> φ = @scalarformula ((V1 > 10) ∧ (V2 < 0) ∧ (V2 < 0) ∧ (V2 <= 0)) ∨ ((V1 <= 0) ∧ ((V1 <= 3)) ∧ (V2 >= 2))\nSyntaxBranch: (V1 > 10 ∧ V2 < 0 ∧ V2 < 0 ∧ V2 ≤ 0) ∨ (V1 ≤ 0 ∧ V1 ≤ 3 ∧ V2 ≥ 2)\n\nSee also parseformula, syntaxstring.\n\n\n\n\n\n","category":"macro"},{"location":"#SoleData.BASE_FEATURE_FUNCTIONS_ALIASES","page":"Home","title":"SoleData.BASE_FEATURE_FUNCTIONS_ALIASES","text":"Syntaxstring aliases for standard features, such as \"min\", \"max\", \"avg\".\n\n\n\n\n\n","category":"constant"},{"location":"#SoleData.AbstractUnivariateFeature","page":"Home","title":"SoleData.AbstractUnivariateFeature","text":"abstract type AbstractUnivariateFeature <: VarFeature end\n\nA dimensional feature represented by the application of a function to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, UnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultivariateFeature","page":"Home","title":"SoleData.MultivariateFeature","text":"struct MultivariateFeature{U} <: VarFeature\n    f::Function\nend\n\nA dimensional feature represented by the application of a function to a dimensional channel. For example, it can wrap a scalar function computing how much a Interval2D world, when interpreted on an image, resembles a horse. Note that the image has a number of spatial variables (3, for the case of RGB), and \"resembling a horse\" may require a computation involving all variables.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateFeature","page":"Home","title":"SoleData.UnivariateFeature","text":"struct UnivariateFeature{U,I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\n    f::Function\n    fname::Union{Nothing,String}\nend\n\nA dimensional feature represented by the application of a generic function f to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains. Optionally, a feature name fname can be attached to the function, which can be useful for inspection (e.g., if f is an anonymous function, this avoids names such s \"#47\" or \"#49\".\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateNamedFeature","page":"Home","title":"SoleData.UnivariateNamedFeature","text":"struct UnivariateNamedFeature{U,I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\n    name::String\nend\n\nA univariate feature solely identified by its name and reference variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VarFeature","page":"Home","title":"SoleData.VarFeature","text":"abstract type VarFeature <: AbstractFeature end\n\nAbstract type for feature functions that can be computed on (multi)variate data. Instances of multivariate datasets have values for a number of variables, which can be used to define logical features.\n\nFor example, with dimensional data (e.g., multivariate time series, digital images and videos), features can be computed as the minimum value for a given variable on a specific interval/rectangle/cuboid (in general, a SoleLogics.GeometricalWorld).\n\nAs an example of a dimensional feature, consider min[V1], which computes the minimum for variable 1 for a given world. ScalarConditions such as min[V1] >= 10 can be, then, evaluated on worlds.\n\nSee also scalarlogiset, featvaltype, computefeature, SoleLogics.Interval.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableDistance","page":"Home","title":"SoleData.VariableDistance","text":"struct VariableDistance{I<:VariableId,T} <: AbstractUnivariateFeature\n    i_variable::I\n    reference::T\n    distance::Function\nend\n\nUnivariate feature computing a distance function for a given variable, with respect to a certain reference structure.\n\nBy default, the distance function is a \n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableMax","page":"Home","title":"SoleData.VariableMax","text":"struct VariableMax{I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\nend\n\nNotable univariate feature computing the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableMin","page":"Home","title":"SoleData.VariableMin","text":"struct VariableMin{I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\nend\n\nNotable univariate feature computing the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableSoftMax","page":"Home","title":"SoleData.VariableSoftMax","text":"struct VariableSoftMax{T<:AbstractFloat,I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableSoftMin","page":"Home","title":"SoleData.VariableSoftMin","text":"struct VariableSoftMin{T<:AbstractFloat,I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableValue","page":"Home","title":"SoleData.VariableValue","text":"struct VariableValue{I<:VariableId} <: AbstractUnivariateFeature\n    i_variable::I\nend\n\nA simple feature, equal the value of a scalar variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.computefeature-Tuple{VarFeature, Any}","page":"Home","title":"SoleData.computefeature","text":"computefeature(f::VarFeature, featchannel; kwargs...)\n\nCompute a feature on a featchannel (i.e., world reading) of an instance.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.computeunivariatefeature-Tuple{SoleData.AbstractUnivariateFeature, Any}","page":"Home","title":"SoleData.computeunivariatefeature","text":"computeunivariatefeature(f::AbstractUnivariateFeature, varchannel; kwargs...)\n\nCompute a feature on a variable channel (i.e., world reading) of an instance.\n\nSee also AbstractUnivariateFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.featvaltype-Tuple{Any, VarFeature}","page":"Home","title":"SoleData.featvaltype","text":"featvaltype(dataset, f::VarFeature)\n\nReturn the type of the values returned by feature f on logiseed dataset.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.parsefeature-Union{Tuple{FT}, Tuple{Type{FT}, AbstractString}} where FT<:VarFeature","page":"Home","title":"SoleData.parsefeature","text":"parsefeature(FT::Type{<:VarFeature}, expr::AbstractString; kwargs...)\n\nParse a VarFeature of type FT from its syntaxstring representation.\n\nKeyword Arguments\n\nfeatvaltype::Union{Nothing,Type} = nothing: the feature's featvaltype   (recommended for some features, e.g., UnivariateFeature);\nopening_parenthesis::String = \"[\":   the string signaling the opening of an expression block (e.g., \"min[V2]\");\nclosing_parenthesis::String = \"]\":   the string signaling the closing of an expression block (e.g., \"min[V2]\");\nadditional_feature_aliases = Dict{String,Base.Callable}(): A dictionary mapping strings to   callables, useful when parsing custom-made, non-standard features.   By default, features such as \"avg\" or \"min\" are provided for   (see SoleData.BASE_FEATURE_FUNCTIONS_ALIASES);   note that, in case of clashing strings,   the provided additional aliases will override the standard ones;\nvariable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing:   mapping from variable name to variable index, useful when parsing from   syntaxstrings with variable names (e.g., \"min[Heart rate]\");\nvariable_name_prefix::String = \"V\":   prefix used with variable indices (e.g., \"V10\").\n\nNote that at most one argument in variable_names_map and variable_name_prefix should be provided.\n\nnote: Note\nThe default parentheses, here, differ from those of SoleLogics.parseformula, since features are typically wrapped into Atoms, and parseformula does not allow parenthesis characters in atoms' syntaxstrings.\n\nSee also VarFeature, featvaltype, parsecondition.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.variable_name-Tuple{SoleData.AbstractUnivariateFeature}","page":"Home","title":"SoleData.variable_name","text":"variable_name(\n    f::AbstractUnivariateFeature;\n    variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing,\n    variable_name_prefix::Union{Nothing,String} = \"V\",\n)::String\n\nReturn the name of the variable targeted by a univariate feature. By default, an variable name is a number prefixed by \"V\"; however, variable_names_map or variable_name_prefix can be used to customize variable names. The prefix can be customized by specifying variable_name_prefix. Alternatively, a mapping from string to integer (either via a Dictionary or a Vector) can be passed as variable_names_map. Note that only one in variable_names_map and variable_name_prefix should be provided.\n\nSee also parsecondition, ScalarCondition, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.Aggregator","page":"Home","title":"SoleData.Aggregator","text":"const Aggregator = Function\n\nA test operator is a binary Julia Function used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <, >, ≥, ≤, !=, and == are typically used.\n\nSee also ScalarCondition, ScalarOneStepMemoset, TestOperator.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.TestOperator","page":"Home","title":"SoleData.TestOperator","text":"const TestOperator = Function\n\nA test operator is a binary Julia Function used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <, >, ≥, ≤, !=, and == are typically used.\n\nSee also Aggregator, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}","page":"Home","title":"SoleData.apply_test_operator","text":"Apply a test operator by simply passing the feature value and threshold to the (binary) test operator function.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.ObliqueScalarCondition","page":"Home","title":"SoleData.ObliqueScalarCondition","text":"ObliqueScalarCondition(features, b, u, test_operator)\n\nAn oblique scalar condition (see oblique decision trees), such as ((features - b)  u)  0, where features is a set of m features, and bu  ℝ^m.\n\nSee also AbstractScalarCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.RangeScalarCondition","page":"Home","title":"SoleData.RangeScalarCondition","text":"struct RangeScalarCondition{U<:Number,FT<:AbstractFeature} <: AbstractScalarCondition{FT}\n\nA condition specifying a range of values for a scalar feature.\n\nFields:\n\nfeature: the scalar feature\nminval, maxval: the minimum and maximum values of the range\nminincluded, maxincluded: whether to include the minimum and maximum values in the range, respectively\n\nThe range is specified using interval notation, where the minimum value is included if minincluded is true and excluded if it is false. Similarly, the maximum value is included if maxincluded is true and excluded if it is false.\n\nFor example, if minincluded == true and maxincluded == false, the range is [minval, maxval).\n\nThe checkcondition method checks whether the value of the feature is within the specified range.\n\nThe syntaxstring method returns a string representation of the condition in the form feature ∈ [minval, maxval], where the interval notation is used to indicate whether the minimum and maximum values are included or excluded.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarCondition","page":"Home","title":"SoleData.ScalarCondition","text":"struct ScalarCondition{U,FT<:AbstractFeature,M<:ScalarMetaCondition{FT}} <: AbstractScalarCondition{FT}\n    metacond::M\n    a::U\nend\n\nA scalar condition comparing a computed feature value (see ScalarMetaCondition) and a threshold value a. It can be evaluated on a world of an instance of a logical dataset.\n\nFor example: minV1  10, which translates to \"Within this world, the minimum of variable 1 is greater or equal than 10.\" In this case, the feature a VariableMin object.\n\nSee also AbstractScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarMetaCondition","page":"Home","title":"SoleData.ScalarMetaCondition","text":"struct ScalarMetaCondition{FT<:AbstractFeature,O<:TestOperator} <: AbstractScalarCondition{FT}\n    feature::FT\n    test_operator::O\nend\n\nA metacondition representing a scalar comparison method. Here, the feature is a scalar function that can be computed on a world of an instance of a logical dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see ScalarCondition). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see UnboundedScalarAlphabet): minV1  a a  ℝ.\n\nSee also AbstractScalarCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateScalarAlphabet","page":"Home","title":"SoleData.UnivariateScalarAlphabet","text":"struct UnivariateScalarAlphabet <: AbstractAlphabet{ScalarCondition}\n    featcondition::Tuple{ScalarMetaCondition,Vector}\nend\n\nA finite alphabet of conditions, grouped by (a finite set of) metaconditions.\n\nSee also UnboundedScalarAlphabet, ScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarExistentialFormula","page":"Home","title":"SoleData.ScalarExistentialFormula","text":"Templated formula for ⟨R⟩ f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarFormula","page":"Home","title":"SoleData.ScalarFormula","text":"Abstract type for templated formulas on scalar conditions.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarUniversalFormula","page":"Home","title":"SoleData.ScalarUniversalFormula","text":"Templated formula for [R] f ⋈ t.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.featvalue-Tuple{AbstractFeature, Any, Integer, Any}","page":"Home","title":"SoleData.featvalue","text":"featvalue(feature, logiseed, i_instance, w)\n\nReturn the value of a feature at world on an instance of a logiset.\n\nSee islogiseed.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.islogiseed-Tuple{Any}","page":"Home","title":"SoleData.islogiseed","text":"islogiseed(dataset)::Bool\n\nA logiseed is a dataset that can be converted to a logiset (e.g., via scalarlogiset). If the dataset is a unimodal logiseed, the following methods should be defined:\n\n    islogiseed(::typeof(dataset)) = true\n    initlogiset(dataset, features; kwargs...)\n    ninstances(dataset)\n    nvariables(dataset)\n    frame(dataset, i_instance::Integer)\n    featvalue(feature::VarFeature, dataset, i_instance::Integer, w::AbstractWorld)\n    varnames(dataset)::Union{Nothing,Vector{<:Union{Integer, Symbol}}}\n    vareltype(dataset, i_variable::Union{Integer, Symbol})\n\nIf dataset is a multimodal logiseed, the following methods should be defined, while its modalities (iterated via eachmodality) should provide the methods above:\n\n    ismultilogiseed(::typeof(dataset)) = true\n    nmodalities(logiseed)\n    eachmodality(logiseed)\n\nExamples\n\nA DataFrame\n\njulia> using DataFrames; df = DataFrame(rand(150, 4), :auto);\n\n\njulia> SoleData.islogiseed(df)\ntrue\n\njulia> ninstances(df), nvariables(df)\n(150, 4)\n\njulia> SoleData.varnames(df)\n4-element Vector{String}:\n \"x1\"\n \"x2\"\n \"x3\"\n \"x4\"\n\n\nA Vector of multidimensional instances (i.e., instances that are Array{Number,N} with N ≥ 1, where the last dimension is that of variables)\n\njulia> X = [rand(4) for i in 1:150];\n\n\njulia> SoleData.islogiseed(X)\ntrue\n\njulia> ninstances(X), nvariables(X)\n(150, 4)\n\njulia> SoleData.varnames(X)\nnothing\n\n\nSee also AbstractLogiset, scalarlogiset.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.ismultilogiseed-Tuple{Any}","page":"Home","title":"SoleData.ismultilogiseed","text":"ismultilogiseed(dataset)::Bool\n\nSee islogiseed.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}","page":"Home","title":"SoleData.naturalgrouping","text":"naturalgrouping(\n    X::AbstractDataFrame;\n    allow_variable_drop = false,\n)::AbstractVector{<:AbstractVector{<:Symbol}}\n\nReturn variables grouped by their logical nature; the nature of a variable is automatically derived from its type (e.g., Real, Vector{<:Real} or Matrix{<:Real}) and frame. All instances must have the same frame (e.g., channel size/number of worlds).\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.scalaralphabet-Tuple{SoleLogics.AbstractAlphabet{<:ScalarCondition}, Vararg{Any}}","page":"Home","title":"SoleData.scalaralphabet","text":"scalaralphabet(a::AbstractAlphabet{<:ScalarCondition}, args...; kwargs...)\n\nTODO explain args and kwargs...\n\nsorted: whether to sort the atoms in the sub-alphabets (i.e., the threshold domains),   by a truer-first policy (default: true)\ntest_operators: test operators to use (defaulted to [≤, ≥] for real-valued features, and [(==), (≠)] for other features, e.g., categorical)\n\nReturn a MultivariateScalarAlphabet from an alphabet of ScalarCondition's.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.scalarlogiset","page":"Home","title":"SoleData.scalarlogiset","text":"scalarlogiset(dataset, features; kwargs...)\n\nConvert a dataset structure (with variables) to a logiset with scalar-valued features. Refer to islogiseed for the interface that dataset must adhere to.\n\nArguments\n\ndataset: the dataset that will be transformed into a logiset. It should adhere to the islogiseed interface;\nfeatures: vector of features, corresponding to dataset columns;\n\nKeyword Arguments\n\nuse_onestep_memoization::Union{Bool,Type{<:AbstractOneStepMemoset}}=!isnothing(conditions) && !isnothing(relations):\n\nenable one-step memoization, optimizing the checking of specific, short formulas using specific scalar conditions and relations (see AbstractOneStepMemoset);\n\nconditions::Union{Nothing,AbstractVector{<:AbstractCondition}}=nothing:\n\na set of conditions or metaconditions to be used in one-step memoization. If not provided, metaconditions given by minimum and maximum applied to each variable will be used (see ScalarMetaCondition);\n\nrelations::Union{Nothing,AbstractVector{<:AbstractRelation}}=nothing:\n\na set of relations to be used in one-step memoization (see AbstractRelation);\n\nonestep_precompute_globmemoset::Bool = (use_onestep_memoization != false):\n\nprecompute the memoization set for global one-step formulas. This usually takes little time: in facto, because, global formulas are grounded, the intermediate check result does not depend on the number of worlds.\n\nonestep_precompute_relmemoset::Bool = false:\n\nprecompute the memoization set for global one-step formulas. This may take a long time, depending on the relations and the number of worlds; it is usually not needed.\n\nuse_full_memoization::Union{Bool,Type{<:Union{AbstractOneStepMemoset,AbstractFullMemoset}}}=true:\n\nenable full memoization, where every intermediate check result is cached to avoid recomputing. This can be used in conjunction with one-step memoization;\n\nprint_progress::Bool = false: print a progress bar;\nallow_propositional::Bool = false: allows a tabular (i.e, non-relational) dataset to be instantiated as a PropositionalLogiset, instead of a modal logiset;\nforce_i_variables::Bool = false: when conditions are to be inferred (conditions = nothing), force (meta)conditions to refer to variables by their integer index, instead of their Symbol name (when available through varnames, see islogiseed).\n\nLogiseed-specific Keyword Arguments\n\nworldtype_by_dim::AbstractDict{<:Integer,<:Type} = Dict([0 => OneWorld, 1 => Interval, 2 => Interval2D]):\n\nWhen the dataset is a MultiData.AbstractDimensionalDataset, this map between the dimensionality and the desired AbstractWorld type is used to infer the frame type. By default, dimensional datasets of dimensionalities 0, 1 and 2 will generate logisets based on OneWorld, Interval's, and Interval2D's, respectively.\n\nExamples\n\njulia> df = DataFrame(A = [36, 37, 38], B = [1, 2, 3])\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │    36      1\n   2 │    37      2\n   3 │    38      3\n\njulia> scalarlogiset(df; worldtype_by_dim=([0=>OneWorld]))\nSupportedLogiset with 1 support (2.21 KBs)\n├ worldtype:                   OneWorld\n├ featvaltype:                 Int64\n├ featuretype:                 VariableValue\n├ frametype:                   SoleLogics.FullDimensionalFrame{0, OneWorld}\n├ # instances:                 3\n├ usesfullmemo:                true\n├[BASE] UniformFullDimensionalLogiset of dimensionality 0 (688.0 Bytes)\n│ ├ size × eltype:              (3, 2) × Int64\n│ └ features:                   2 -> VariableValue[V1, V2]\n└[SUPPORT 1] FullMemoset (0 memoized values, 1.5 KBs))\n\njulia> pointlogiset = scalarlogiset(     Xdf;     worldtypeby_dim=Dict([1 => SoleLogics.Point1D, 2 => SoleLogics.Point2D]) )\n\nSee also AbstractModalLogiset, AbstractOneStepMemoset, SoleLogics.AbstractRelation, SoleLogics.AbstractWorld, ScalarCondition, VarFeature.\n\n\n\n\n\n","category":"function"},{"location":"#SoleData.AbstractScalarOneStepGlobalMemoset","page":"Home","title":"SoleData.AbstractScalarOneStepGlobalMemoset","text":"Abstract type for one-step memoization structure for checking \"global\" formulas of type ⟨G⟩ (f ⋈ t).     We refer to these structures as global memosets.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarOneStepRelationalMemoset","page":"Home","title":"SoleData.ScalarOneStepRelationalMemoset","text":"A generic, one-step memoization structure used for checking specific formulas of scalar conditions on datasets with scalar features. The formulas are of type ⟨R⟩ (f ⋈ t)\n\nSee also AbstractScalarOneStepRelationalMemoset, FullMemoset, SupportedLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.PropositionalLogiset","page":"Home","title":"SoleData.PropositionalLogiset","text":"PropositionalLogiset(table) <: AbstractPropositionalLogiset\n\nA logiset of propositional interpretations, wrapping a Tables' table of real/string/categorical values.\n\nExamples\n\nThis structure can be used to check propositional formulas:\n\nusing SoleData, MLJBase\n\nX = PropositionalLogiset(MLJBase.load_iris())\n\nφ = parseformula(\n    \"sepal_length > 5.8 ∧ sepal_width < 3.0 ∨ target == \"setosa\"\";\n    atom_parser = a->Atom(parsecondition(SoleData.ScalarCondition, a; featuretype = SoleData.VariableValue))\n)\n\ncheck(φ, X, 10) # Check the formula on a single instance\n\nsatmask = check(φ, X) # Check the formula on the whole dataset\n\nslicedataset(X, satmask)\nslicedataset(X, (!).(satmask))\n\nSee also AbstractLogiset, AbstractAssignment.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.alphabet","page":"Home","title":"SoleLogics.alphabet","text":"alphabet(\n    X::PropositionalLogiset,\n    sorted=true;\n    test_operators::Union{Nothing,AbstractVector{<:TestOperator},Base.Callable}=nothing,\n    discretizedomain=false,\n    y::Union{Nothing, AbstractVector}=nothing,\n)::MultivariateScalarAlphabet\n\nConstructs an alphabet based on the provided PropositionalLogiset X, with optional parameters:\n\nsorted: whether to sort the atoms in the sub-alphabets (i.e., the threshold domains),   by a truer-first policy (default: true)\ntest_operators: test operators to use (defaulted to [≤, ≥] for real-valued features, and [(==), (≠)] for other features, e.g., categorical)\ndiscretizedomain: whether to discretize the domain (default: false)\ny: vector used for discretization (required if discretizedomain is true)\n\nReturns a UnionAlphabet containing ScalarCondition and UnivariateScalarAlphabet.\n\n\n\n\n\n","category":"function"},{"location":"#Scalar-Dimensional-Logisets","page":"Home","title":"Scalar Dimensional Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData, SoleData.DimensionalDatasets]\nPages   = [\n\t\"dimensional-structures/main.jl\",\n\t\"dimensional-structures/logiset.jl\",\n\t\"dimensional-structures/onestep-memosets.jl\",\n\t\"dimensional-structures/computefeature.jl\",\n\t\"dimensional-structures/logiseeds/abstractdataframe.jl\",\n\t\"dimensional-structures/logiseeds/abstractdimensionaldataset.jl\",\n\t\"dimensional-structures/logiseeds/namedtuple.jl\",\n]","category":"page"},{"location":"#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset","page":"Home","title":"SoleData.DimensionalDatasets.UniformFullDimensionalLogiset","text":"struct UniformFullDimensionalLogiset{\n    U,\n    W<:AbstractWorld,\n    N,\n    D<:AbstractArray{U},\n    FT<:AbstractFeature,\n    FR<:FullDimensionalFrame{N,W},\n} <: AbstractUniformFullDimensionalLogiset{U,N,W,FT,FR}\n\nUniform scalar logiset with full dimensional frames of dimensionality N, storing values for each world in a ninstances × nfeatures array.\n\nThe size of the internal structure (or featstruct) depends on the (unique) world type considered.\n\nExamples\n\nInterval-based frames\n\nWith an interval-based, N-dimensional frame, the worlds are N-intervals, and have 2*N parameters, which are used to index an (N*2+2)-dimensional featstruct (recall that two dimensions are reserved for instances and features).\n\nFor example, consider the case of a 1-dimensional frame with three points:         1       2       3     ─────────────────────────\n\nGiven an instance and a feature, the featstruct will map the hyper-intervals across two dimensions: ┌───┬───────┬───────┬───────┐ │   │   1   │   2   │   3   │ ├───┼───────┼───────┼───────┤ │ 1 │ [1,1] │ [1,2] │ [1,3] │ ├───┼───────┼───────┼───────┤ │ 2 │       │ [2,2] │ [2,3] │ ├───┼───────┼───────┼───────┤ │ 3 │       │       │ [3,3] │ └───┴───────┴───────┴───────┘\n\nSee also AbstractModalLogiset, AbstractUniformFullDimensionalLogiset, SoleLogics.FullDimensionalFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset","page":"Home","title":"SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset","text":"A relational memoset optimized for uniform scalar logisets with full dimensional frames of dimensionality N, storing values for each world in a ninstances × nmetaconditions × nrelations array. Each world is a hyper-interval, and its N*2 components are used to index different array dimensions, ultimately resulting in a (N*2+3)-dimensional array.\n\nSee also UniformFullDimensionalLogiset, FullDimensionalFrame, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.initlogiset-Tuple{AbstractVector{<:AbstractArray{T, D}} where {T<:Number, D}, AbstractVector}","page":"Home","title":"SoleData.initlogiset","text":"function initlogiset(\n    dataset::AbstractDimensionalDataset,\n    features::AbstractVector;\n    worldtype_by_dim::Union{Nothing,AbstractDict{<:Integer,<:Type}}=nothing\n)::UniformFullDimensionalLogiset\n\nGiven an AbstractDimensionalDataset, build a UniformFullDimensionalLogiset.\n\nKeyword Arguments\n\nworldtypebydim::Union{Nothing,AbstractDict{<:Integer,<:Type}}=nothing:\n\nmap between a dimensionality, as integer, and the AbstractWorld type associated; when unspecified, this is defaulted to Dict(0 => OneWorld, 1 => Interval, 2 => Interval2D).\n\nSee also AbstractDimensionalDataset, SoleLogics.AbstractWorld, MultiData.dimensionality, UniformFullDimensionalLogiset.\n\n\n\n\n\n","category":"method"},{"location":"#Multimodal-Logisets","page":"Home","title":"Multimodal Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"utils/multilogiset.jl\",]","category":"page"},{"location":"#SoleData.MultiFormula","page":"Home","title":"SoleData.MultiFormula","text":"struct MultiFormula{F<:Formula} <: AbstractSyntaxStructure\n    modforms::Dict{Int,F}\nend\n\nA logical formula that can be checked on a MultiLogiset, representing the logical and between formulas across different modalities.\n\nSee also MultiLogiset, eachmodality, nmodalities, modforms.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultiLogiset","page":"Home","title":"SoleData.MultiLogiset","text":"struct MultiLogiset{L<:AbstractLogiset}\n    modalities  :: Vector{L}\nend\n\nA logical dataset composed of different modalities); this structure is useful for representing multimodal datasets in logical terms.\n\nSee also AbstractLogiset, minify.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.modforms-Tuple{MultiFormula}","page":"Home","title":"SoleData.modforms","text":"Return a dictionary associating different formulas to different dataset modalities. \n\nSee also MultiFormula, MultiLogiset.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"<!– ## MLJ Integration","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"types/logiset-MLJ-interface.jl\",]","category":"page"},{"location":"","page":"Home","title":"Home","text":"–>","category":"page"},{"location":"#Optimizations","page":"Home","title":"Optimizations","text":"","category":"section"},{"location":"#Representatives","page":"Home","title":"Representatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\n\t\"types/representatives.jl\",\n\t\"scalar/representatives.jl\",\n]","category":"page"},{"location":"#SoleData.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W<:AbstractWorld","page":"Home","title":"SoleData.representatives","text":"representatives(\n    fr::AbstractFrame{W},\n    S::W,\n    ::AbstractRelation,\n    ::AbstractCondition\n) where {W<:AbstractWorld}\n\nReturn an iterator to the (few) representative accessible worlds that are necessary for computing and propagating truth values through existential modal connectives. When this optimization is possible (e.g., when checking specific formulas on scalar conditions), it allows to further boost \"one-step\" optimizations (see AbstractOneStepMemoset).\n\nFor example, consider a Kripke structure with a 1-dimensional FullDimensionalFrame of length 100, and the problem of checking a formula \"⟨L⟩(max[V1] ≥ 10)\" on a SoleLogics.Interval SoleLogics.Interval{Int64}(1, 2) (with L being Allen's \"Later\" relation, see SoleLogics.IA_L). Comparing 10 with the (maximum) \"max[V1]\" computed on all worlds is the naïve strategy to check the formula. However, in this case, comparing 10 to the \"max[V1]\" computed on the single Interval SoleLogics.Interval{Int64}(2, 101) suffice to establish whether the structure satisfies the formula. Similar cases arise depending on the relation, feature and test operator (or, better, its aggregator).\n\nNote that this method fallsback to accessibles.\n\nSee also SoleLogics.accessibles, ScalarCondition, SoleLogics.AbstractFrame.\n\n\n\n\n\n","category":"method"}]
}
