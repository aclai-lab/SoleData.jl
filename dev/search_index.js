var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleData","category":"page"},{"location":"#SoleData","page":"Home","title":"SoleData","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleData.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Logical-foundations","page":"Home","title":"Logical foundations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See SoleLogics for more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.Atom\nSoleLogics.AbstractWorld\nSoleLogics.Interval\nSoleLogics.Interval2D\nSoleLogics.syntaxstring\nSoleLogics.IA_L\nSoleLogics.AbstractFrame\nSoleLogics.accessibles\nminify","category":"page"},{"location":"#SoleLogics.Atom","page":"Home","title":"SoleLogics.Atom","text":"struct Atom{V} <: SyntaxLeaf\n    value::V\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{V} wraps a value::V representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractInterpretation, atoms, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.AbstractWorld","page":"Home","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Interval","page":"Home","title":"SoleLogics.Interval","text":"struct Interval{T} <: GeometricalWorld\n    x :: T\n    y :: T\nend\n\nAn interval in a 1-dimensional space, with coordinates of type T.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)\ntrue\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)\nfalse\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))\n6-element Vector{Interval{Int64}}:\n (3−4)\n (3−5)\n (4−5)\n (3−6)\n (4−6)\n (5−6)\n\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval2D, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.Interval2D","page":"Home","title":"SoleLogics.Interval2D","text":"struct Interval2D{T} <: GeometricalWorld\n    x :: Interval{T}\n    y :: Interval{T}\nend\n\nA orthogonal rectangle in a 2-dimensional space, with coordinates of type T. This is the 2-dimensional Interval counterpart, that is, the combination of two orthogonal Intervals.\n\nExamples\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)\nfalse\n\njulia> SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)\ntrue\n\njulia> collect(accessibles(SoleLogics.FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))\n3-element Vector{Interval2D{Int64}}:\n ((4−5)×(5−6))\n ((4−6)×(5−6))\n ((5−6)×(5−6))\n\n\nSee also goeswithdim, accessibles, FullDimensionalFrame, Point, Interval, GeometricalWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.syntaxstring","page":"Home","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including the kwargs... part!) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"function"},{"location":"#SoleLogics.IA_L","page":"Home","title":"SoleLogics.IA_L","text":"See IntervalRelation\n\n\n\n\n\n","category":"constant"},{"location":"#SoleLogics.AbstractFrame","page":"Home","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures. A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.accessibles","page":"Home","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\naccessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{<:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"function"},{"location":"#SoleData.minify","page":"Home","title":"SoleData.minify","text":"minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}\n\nReturn a minified version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.\n\nSee also isminifiable.\n\n\n\n\n\n","category":"function"},{"location":"#Logisets","page":"Home","title":"Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"features.jl\", \"conditions.jl\"]","category":"page"},{"location":"#SoleData.BASE_FEATURE_FUNCTIONS_ALIASES","page":"Home","title":"SoleData.BASE_FEATURE_FUNCTIONS_ALIASES","text":"Syntaxstring aliases for standard features, such as \"min\", \"max\", \"avg\".\n\n\n\n\n\n","category":"constant"},{"location":"#SoleData.AbstractFeature","page":"Home","title":"SoleData.AbstractFeature","text":"abstract type AbstractFeature end\n\nAbstract type for features of worlds of [Kripke structures](https://en.wikipedia.org/wiki/Kripkestructure(model_checking).\n\nSee also VarFeature, featvaltype, SoleLogics.AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractUnivariateFeature","page":"Home","title":"SoleData.AbstractUnivariateFeature","text":"abstract type AbstractUnivariateFeature <: VarFeature end\n\nA dimensional feature represented by the application of a function to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, UnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ExplicitFeature","page":"Home","title":"SoleData.ExplicitFeature","text":"struct ExplicitFeature{T} <: AbstractFeature\n    name::String\n    featstruct\nend\n\nA feature encoded explicitly, for example, as a slice of DimensionalDatasets.UniformFullDimensionalLogiset's feature structure.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.Feature","page":"Home","title":"SoleData.Feature","text":"struct Feature{A} <: AbstractFeature\n    atom::A\nend\n\nA feature solely identified by an atom (e.g., a string with its name, a tuple of strings, etc.)\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultivariateFeature","page":"Home","title":"SoleData.MultivariateFeature","text":"struct MultivariateFeature{U} <: VarFeature\n    f::Function\nend\n\nA dimensional feature represented by the application of a function to a dimensional channel. For example, it can wrap a scalar function computing how much a Interval2D world, when interpreted on an image, resembles a horse. Note that the image has a number of spatial variables (3, for the case of RGB), and \"resembling a horse\" may require a computation involving all variables.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateFeature","page":"Home","title":"SoleData.UnivariateFeature","text":"struct UnivariateFeature{U} <: AbstractUnivariateFeature\n    i_variable::Integer\n    f::Function\nend\n\nA dimensional feature represented by the application of a generic function f to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a Interval2D world, when interpreted on an image, contains.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateNamedFeature","page":"Home","title":"SoleData.UnivariateNamedFeature","text":"struct UnivariateNamedFeature{U} <: AbstractUnivariateFeature\n    i_variable::Integer\n    name::String\nend\n\nA univariate feature solely identified by its name and reference variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VarFeature","page":"Home","title":"SoleData.VarFeature","text":"abstract type VarFeature <: AbstractFeature end\n\nAbstract type for feature functions that can be computed on (multi)variate data. Instances of multivariate datasets have values for a number of variables, which can be used to define logical features.\n\nFor example, with dimensional data (e.g., multivariate time series, digital images and videos), features can be computed as the minimum value for a given variable on a specific interval/rectangle/cuboid (in general, a `SoleLogics.GeometricalWorld).\n\nAs an example of a dimensional feature, consider min[V1], which computes the minimum for variable 1 for a given world. ScalarConditions such as min[V1] >= 10 can be, then, evaluated on worlds.\n\nSee also scalarlogiset, featvaltype, computefeature, SoleLogics.Interval.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableMax","page":"Home","title":"SoleData.VariableMax","text":"struct VariableMax <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nNotable univariate feature computing the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableMin","page":"Home","title":"SoleData.VariableMin","text":"struct VariableMin <: AbstractUnivariateFeature\n    i_variable::Integer\nend\n\nNotable univariate feature computing the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableSoftMax","page":"Home","title":"SoleData.VariableSoftMax","text":"struct VariableSoftMax{T<:AbstractFloat} <: AbstractUnivariateFeature\n    i_variable::Integer\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the maximum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMax, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableSoftMin","page":"Home","title":"SoleData.VariableSoftMin","text":"struct VariableSoftMin{T<:AbstractFloat} <: AbstractUnivariateFeature\n    i_variable::Integer\n    alpha::T\nend\n\nUnivariate feature computing a \"softened\" version of the minimum value for a given variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VariableMin, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.VariableValue","page":"Home","title":"SoleData.VariableValue","text":"struct VariableValue <: AbstractUnivariateFeature\n    i_variable::Union{Integer,Symbol}\nend\n\nA simple feature, equal the value of a scalar variable.\n\nSee also SoleLogics.Interval, SoleLogics.Interval2D, AbstractUnivariateFeature, VarFeature, AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.computefeature-Tuple{VarFeature, Any}","page":"Home","title":"SoleData.computefeature","text":"computefeature(f::VarFeature, featchannel; kwargs...)\n\nCompute a feature on a featchannel (i.e., world reading) of an instance.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.computeunivariatefeature-Tuple{SoleData.AbstractUnivariateFeature, Any}","page":"Home","title":"SoleData.computeunivariatefeature","text":"computeunivariatefeature(f::AbstractUnivariateFeature, varchannel; kwargs...)\n\nCompute a feature on a variable channel (i.e., world reading) of an instance.\n\nSee also AbstractUnivariateFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.featvaltype-Tuple{Any, VarFeature}","page":"Home","title":"SoleData.featvaltype","text":"featvaltype(dataset, f::VarFeature)\n\nReturn the type of the values returned by feature f on logiseed dataset.\n\nSee also VarFeature.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.parsefeature-Tuple{Type{<:AbstractFeature}, String}","page":"Home","title":"SoleData.parsefeature","text":"parsefeature(FT::Type{<:AbstractFeature}, expr::String; kwargs...)\n\nParse a feature of type FT from its syntaxstring representation. Depending on FT, specifying keyword arguments such as featvaltype::Type may be required or recommended.\n\nSee also parsecondition.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.variable_name-Tuple{SoleData.AbstractUnivariateFeature}","page":"Home","title":"SoleData.variable_name","text":"variable_name(\n    f::AbstractUnivariateFeature;\n    variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing,\n    variable_name_prefix::Union{Nothing,String} = \"V\",\n)::String\n\nReturn the name of the variable targeted by a univariate feature. By default, an variable name is a number prefixed by \"V\"; however, variable_names_map or variable_name_prefix can be used to customize variable names. The prefix can be customized by specifying variable_name_prefix. Alternatively, a mapping from string to integer (either via a Dictionary or a Vector) can be passed as variable_names_map. Note that only one in variable_names_map and variable_name_prefix should be provided.\n\nSee also parsecondition, ScalarCondition, syntaxstring.\n\n\n\n\n\n","category":"method"},{"location":"#SoleData.AbstractCondition","page":"Home","title":"SoleData.AbstractCondition","text":"abstract type AbstractCondition{FT<:AbstractFeature} end\n\nAbstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a logical dataset. In logical contexts, these are wrapped into Atoms.\n\nSee also Atom, syntaxstring, ScalarMetaCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.FunctionalCondition","page":"Home","title":"SoleData.FunctionalCondition","text":"struct FunctionalCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\n    f::FT\nend\n\nA condition which yields a truth value equal to the value of a function.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ObliqueScalarCondition","page":"Home","title":"SoleData.ObliqueScalarCondition","text":"ObliqueScalarCondition(features, b, u, test_operator)\n\nAn oblique scalar condition (see oblique decision trees), such as ((features - b)  u)  0, where features is a set of m features, and bu  ℝ^m.\n\nSee also AbstractCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarCondition","page":"Home","title":"SoleData.ScalarCondition","text":"struct ScalarCondition{U,FT,M<:ScalarMetaCondition{FT}} <: AbstractCondition{FT}\n    metacond::M\n    a::U\nend\n\nA scalar condition comparing a computed feature value (see ScalarMetaCondition) and a threshold value a. It can be evaluated on a world of an instance of a logical dataset.\n\nFor example: minV1  10, which translates to \"Within this world, the minimum of variable 1 is greater or equal than 10.\" In this case, the feature a VariableMin object.\n\nSee also AbstractCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarMetaCondition","page":"Home","title":"SoleData.ScalarMetaCondition","text":"struct ScalarMetaCondition{FT<:AbstractFeature,O<:TestOperator} <: AbstractCondition{FT}\n    feature::FT\n    test_operator::O\nend\n\nA metacondition representing a scalar comparison method. Here, the feature is a scalar function that can be computed on a world of an instance of a logical dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see ScalarCondition). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see UnboundedScalarAlphabet): minV1  a a  ℝ.\n\nSee also AbstractCondition, ScalarCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.UnivariateScalarAlphabet","page":"Home","title":"SoleData.UnivariateScalarAlphabet","text":"struct UnivariateScalarAlphabet <: AbstractAlphabet{ScalarCondition}\n    featcondition::Vector{UnivariateScalarAlphabet}\nend\n\nA finite alphabet of conditions, grouped by (a finite set of) metaconditions.\n\nSee also UnboundedScalarAlphabet, ScalarCondition, ScalarMetaCondition.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ValueCondition","page":"Home","title":"SoleData.ValueCondition","text":"struct ValueCondition{FT<:AbstractFeature} <: AbstractCondition{FT}\n    feature::FT\nend\n\nA condition which yields a truth value equal to the value of a feature.\n\nSee also AbstractFeature.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.parsecondition-Tuple{Type{<:SoleData.AbstractCondition}, String}","page":"Home","title":"SoleData.parsecondition","text":"parsecondition(C::Type{<:AbstractCondition}, expr::String; kwargs...)\n\nParse a condition of type C from its syntaxstring representation. Depending on C, specifying keyword arguments such as featuretype::Type{<:AbstractFeature}, and featvaltype::Type may be required or recommended.\n\nSee also parsefeature.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"representatives.jl\"]","category":"page"},{"location":"#SoleData.representatives-Union{Tuple{W}, Tuple{SoleLogics.AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W<:AbstractWorld","page":"Home","title":"SoleData.representatives","text":"representatives(\n    fr::AbstractFrame{W},\n    S::W,\n    ::AbstractRelation,\n    ::AbstractCondition\n) where {W<:AbstractWorld}\n\nReturn an iterator to the (few) representative accessible worlds that are necessary for computing and propagating truth values through existential modal connectives. When this optimization is possible (e.g., when checking specific formulas on scalar conditions), it allows to further boost \"one-step\" optimizations (see AbstractOneStepMemoset).\n\nFor example, consider a Kripke structure with a 1-dimensional FullDimensionalFrame of length 100, and the problem of checking a formula \"⟨L⟩(max[V1] ≥ 10)\" on a SoleLogics.Interval SoleLogics.Interval{Int64}(1, 2) (with L being Allen's \"Later\" relation, see SoleLogics.IA_L). Comparing 10 with the (maximum) \"max[V1]\" computed on all worlds is the naïve strategy to check the formula. However, in this case, comparing 10 to the \"max[V1]\" computed on the single Interval SoleLogics.Interval{Int64}(2, 101) suffice to establish whether the structure satisfies the formula. Similar cases arise depending on the relation, feature and test operator (or, better, its aggregator).\n\nNote that this method fallsback to accessibles.\n\nSee also SoleLogics.accessibles, ScalarCondition, SoleLogics.AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"logiset.jl\"]","category":"page"},{"location":"#SoleData.MultiFormula","page":"Home","title":"SoleData.MultiFormula","text":"struct MultiFormula{F<:Formula} <: AbstractSyntaxStructure\n    modforms::Dict{Int,F}\nend\n\nA symbolic antecedent that can be checked on a MultiLogiset, associating antecedents to modalities.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.MultiLogiset","page":"Home","title":"SoleData.MultiLogiset","text":"struct MultiLogiset{L<:AbstractModalLogiset}\n    modalities  :: Vector{L}\nend\n\nA logical dataset composed of different modalities); this structure is useful for representing multimodal datasets in logical terms.\n\nSee also AbstractModalLogiset, minify.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.PropositionalLogiset","page":"Home","title":"SoleData.PropositionalLogiset","text":"PropositionalLogiset(table)\n\nA logiset of propositional interpretations, wrapping a Tables' table of real/string/categorical values.\n\nExamples\n\nThis structure can be used to check propositional formulas:\n\nusing SoleData, MLJBase\n\nX = PropositionalLogiset(MLJBase.load_iris())\n\nφ = parseformula(\n    \"sepal_length > 5.8 ∧ sepal_width < 3.0 ∨ target == \"setosa\"\";\n    atom_parser = a->Atom(parsecondition(SoleData.ScalarCondition, a; featuretype = SoleData.VariableValue))\n)\n\ncheck(φ, X, 10) # Check the formula on a single instance\n\nsatmask = check(φ, X) # Check the formula on the whole dataset\n\nslicedataset(X, satmask)\nslicedataset(X, (!).(satmask))\n\nSee also AbstractLogiset, AbstractAssignment.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.SupportedLogiset","page":"Home","title":"SoleData.SupportedLogiset","text":"A logiset, associated to a number of cascading full or one-step memoization structures, that are used for optimizing the checking of formulas.\n\nSee also SupportedLogiset, AbstractFullMemoset, AbstractOneStepMemoset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleLogics.alphabet","page":"Home","title":"SoleLogics.alphabet","text":"alphabet(X::PropositionalLogiset, sorted=true;\n         test_operators::Union{Nothing,AbstractVector{<:TestOperator},Base.Callable}=nothing,\n         discretizedomain=false, y::Union{Nothing, AbstractVector}=nothing\n)::UnionAlphabet{ScalarCondition,UnivariateScalarAlphabet}\n\nConstructs an alphabet based on the provided PropositionalLogiset X, with optional parameters:\n\nsorted: whether to sort the atoms in the sub-alphabets (i.e., the threshold domains),   by a truer-first policy (default: true)\ntest_operators: test operators to use (defaulted to [≤, ≥] for real-valued features, and [(==), (≠)] for other features, e.g., categorical)\ndiscretizedomain: whether to discretize the domain (default: false)\ny: vector used for discretization (required if discretizedomain is true)\n\nReturns a UnionAlphabet containing ScalarCondition and UnivariateScalarAlphabet.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"memosets.jl\"]","category":"page"},{"location":"#SoleData.AbstractFullMemoset","page":"Home","title":"SoleData.AbstractFullMemoset","text":"Abstract type for full memoization structures for checking generic formulas.\n\nThese structures can be stacked and coupled with one-step memoization structures (see SupportedLogiset).\n\nSee AbstractOneStepMemoset, FullMemoset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractMemoset","page":"Home","title":"SoleData.AbstractMemoset","text":"abstract type AbstractMemoset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame,\n} <: AbstractModalLogiset{W,U,FT,FR} end\n\nAbstract type for memoization structures to be used when checking formulas on logisets.\n\nSee also FullMemoset, SupportedLogiset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractOneStepMemoset","page":"Home","title":"SoleData.AbstractOneStepMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩p; with these formulas, so-called \"one-step\" optimizations can be performed.\n\nThese structures can be stacked and coupled with full memoization structures (see SupportedLogiset).\n\nSee ScalarOneStepMemoset, AbstractFullMemoset, representatives.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.FullMemoset","page":"Home","title":"SoleData.FullMemoset","text":"A generic, full memoization structure that works for any crisp logic; For each instance of a dataset, this structure associates formulas to the set of worlds where the formula holds; it was introduced by Emerson-Clarke for the well-known model checking algorithm for CTL*.\n\nSee also SupportedLogiset, AbstractMemoset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarChainedMemoset","page":"Home","title":"SoleData.ScalarChainedMemoset","text":"A full memoization structure used for checking formulas of scalar conditions on datasets with scalar features. This structure is the equivalent to FullMemoset, but with scalar features some important optimizations can be done.\n\nSee also FullMemoset, SupportedLogiset, AbstractModalLogiset.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"AbstractModalLogiset\nAbstractScalarOneStepRelationalMemoset\nScalarOneStepMemoset","category":"page"},{"location":"#SoleData.AbstractModalLogiset","page":"Home","title":"SoleData.AbstractModalLogiset","text":"abstract type AbstractModalLogiset{\n    W<:AbstractWorld,\n    U,\n    FT<:AbstractFeature,\n    FR<:AbstractFrame{W},\n} <: AbstractLogiset{SoleLogics.AbstractKripkeStructure} end\n\nAbstract type for logisets, that is, logical datasets for symbolic learning where each instance is a Kripke structure associating feature values to each world. Conditions (see AbstractCondition), and logical formulas with conditional letters can be checked on worlds of instances of the dataset.\n\nSee also AbstractCondition, AbstractFeature, SoleLogics.AbstractKripkeStructure, SoleLogics.AbstractInterpretationSet.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.AbstractScalarOneStepRelationalMemoset","page":"Home","title":"SoleData.AbstractScalarOneStepRelationalMemoset","text":"Abstract type for one-step memoization structures for checking formulas of type ⟨R⟩ (f ⋈ t), for a generic relation R that is not the global relation (SoleLogics.globalrel). We refer to these structures as relational memosets.\n\n\n\n\n\n","category":"type"},{"location":"#SoleData.ScalarOneStepMemoset","page":"Home","title":"SoleData.ScalarOneStepMemoset","text":"One-step memoization structures for optimized check of formulas of type ⟨R⟩p, where p wraps a scalar condition, such as MyFeature ≥ 10. With such formulas, scalar one-step optimization can be performed.\n\nFor example, checking ⟨R⟩(MyFeature ≥ 10) on a world w of a Kripke structure involves comparing the maximum MyFeature across ws accessible worlds with 10; but the same maximum value can be reused to check sibling formulas such as ⟨R⟩(MyFeature ≥ 100). This sparks the idea of storing and reusing scalar aggregations (e.g., minimum/maximum) over the feature values. Each value refers to a specific world, and an object of type ⟨R⟩(f ⋈ ?), called a \"scalar metacondition\".\n\nSimilar cases arise depending on the relation and the test operator (or, better, its aggregator), and further optimizations can be applied for specific feature types (see representatives).\n\nAn immediate special case, however, arises when R is the global relation G since, in such case, a single aggregate value is enough for all worlds within the Kripke structure. Therefore, we differentiate between generic, relational memosets (see AbstractScalarOneStepRelationalMemoset), and global memosets (see AbstractScalarOneStepGlobalMemoset), which are usually much smaller.\n\nGiven a logiset X, a ScalarOneStepMemoset covers a set of relations and metaconditions, and it holds both a relational and a global memoset. It can be instantiated via:\n\nScalarOneStepMemoset(\n    X                       :: AbstractModalLogiset{W,U},\n    metaconditions          :: AbstractVector{<:ScalarMetaCondition},\n    relations               :: AbstractVector{<:AbstractRelation};\n    precompute_globmemoset  :: Bool = true,\n    precompute_relmemoset   :: Bool = false,\n    print_progress          :: Bool = false,\n)\n\nIf precompute_relmemoset is false, then the relational memoset is simply initialized as an empty structure, and memoization is performed on it upon checking formulas. precompute_globmemoset works similarly.\n\nSee SupportedLogiset, ScalarMetaCondition, AbstractOneStepMemoset.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"supported-logiset.jl\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"check.jl\"]","category":"page"},{"location":"#Scalar-Logisets","page":"Home","title":"Scalar Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"scalar/main.jl\"]","category":"page"},{"location":"#Scalar-Dimensional-Logisets","page":"Home","title":"Scalar Dimensional Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData, SoleData.DimensionalDatasets]\nPages   = [\"dimensional-structures/main.jl\"]","category":"page"},{"location":"#Multimodal-Logisets","page":"Home","title":"Multimodal Logisets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SoleData]\nPages   = [\"multilogiset.jl\"]","category":"page"}]
}
