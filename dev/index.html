<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SoleData.jl</title><meta name="title" content="Home · SoleData.jl"/><meta property="og:title" content="Home · SoleData.jl"/><meta property="twitter:title" content="Home · SoleData.jl"/><meta name="description" content="Documentation for SoleData.jl."/><meta property="og:description" content="Documentation for SoleData.jl."/><meta property="twitter:description" content="Documentation for SoleData.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleData.jl/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleData.jl/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleData.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SoleData.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Logical-foundations"><span>Logical foundations</span></a></li><li class="toplevel"><a class="tocitem" href="#API"><span>API</span></a></li><li class="toplevel"><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Logisets"><span>Logisets</span></a></li><li><a class="tocitem" href="#Multimodal-Logisets"><span>Multimodal Logisets</span></a></li><li class="toplevel"><a class="tocitem" href="#Optimizations"><span>Optimizations</span></a></li><li><a class="tocitem" href="#Representatives"><span>Representatives</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleData.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleData.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SoleData"><a class="docs-heading-anchor" href="#SoleData">SoleData</a><a id="SoleData-1"></a><a class="docs-heading-anchor-permalink" href="#SoleData" title="Permalink"></a></h1><p>Welcome to the documentation for <a href="https://github.com/aclai-lab/SoleData.jl">SoleData</a>.</p><ul><li><a href="#SoleData.BASE_FEATURE_FUNCTIONS_ALIASES"><code>SoleData.BASE_FEATURE_FUNCTIONS_ALIASES</code></a></li><li><a href="#SoleLogics.IA_L"><code>SoleLogics.IA_L</code></a></li><li><a href="#SoleData.AbstractCondition"><code>SoleData.AbstractCondition</code></a></li><li><a href="#SoleData.AbstractFeature"><code>SoleData.AbstractFeature</code></a></li><li><a href="#SoleData.AbstractFullMemoset"><code>SoleData.AbstractFullMemoset</code></a></li><li><a href="#SoleData.AbstractLogiset"><code>SoleData.AbstractLogiset</code></a></li><li><a href="#SoleData.AbstractMemoset"><code>SoleData.AbstractMemoset</code></a></li><li><a href="#SoleData.AbstractModalLogiset"><code>SoleData.AbstractModalLogiset</code></a></li><li><a href="#SoleData.AbstractOneStepMemoset"><code>SoleData.AbstractOneStepMemoset</code></a></li><li><a href="#SoleData.AbstractScalarOneStepGlobalMemoset"><code>SoleData.AbstractScalarOneStepGlobalMemoset</code></a></li><li><a href="#SoleData.AbstractScalarOneStepRelationalMemoset"><code>SoleData.AbstractScalarOneStepRelationalMemoset</code></a></li><li><a href="#SoleData.AbstractUnivariateFeature"><code>SoleData.AbstractUnivariateFeature</code></a></li><li><a href="#SoleData.Aggregator"><code>SoleData.Aggregator</code></a></li><li><a href="#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><code>SoleData.DimensionalDatasets.UniformFullDimensionalLogiset</code></a></li><li><a href="#SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset"><code>SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset</code></a></li><li><a href="#SoleData.ExplicitBooleanModalLogiset"><code>SoleData.ExplicitBooleanModalLogiset</code></a></li><li><a href="#SoleData.ExplicitFeature"><code>SoleData.ExplicitFeature</code></a></li><li><a href="#SoleData.ExplicitModalLogiset"><code>SoleData.ExplicitModalLogiset</code></a></li><li><a href="#SoleData.Feature"><code>SoleData.Feature</code></a></li><li><a href="#SoleData.FullMemoset"><code>SoleData.FullMemoset</code></a></li><li><a href="#SoleData.FunctionalCondition"><code>SoleData.FunctionalCondition</code></a></li><li><a href="#SoleData.MixedCondition"><code>SoleData.MixedCondition</code></a></li><li><a href="#SoleData.MultiFormula"><code>SoleData.MultiFormula</code></a></li><li><a href="#SoleData.MultiLogiset"><code>SoleData.MultiLogiset</code></a></li><li><a href="#SoleData.MultivariateFeature"><code>SoleData.MultivariateFeature</code></a></li><li><a href="#SoleData.ObliqueScalarCondition"><code>SoleData.ObliqueScalarCondition</code></a></li><li><a href="#SoleData.PropositionalLogiset"><code>SoleData.PropositionalLogiset</code></a></li><li><a href="#SoleData.RangeScalarCondition"><code>SoleData.RangeScalarCondition</code></a></li><li><a href="#SoleData.ScalarCondition"><code>SoleData.ScalarCondition</code></a></li><li><a href="#SoleData.ScalarExistentialFormula"><code>SoleData.ScalarExistentialFormula</code></a></li><li><a href="#SoleData.ScalarFormula"><code>SoleData.ScalarFormula</code></a></li><li><a href="#SoleData.ScalarMetaCondition"><code>SoleData.ScalarMetaCondition</code></a></li><li><a href="#SoleData.ScalarOneStepMemoset"><code>SoleData.ScalarOneStepMemoset</code></a></li><li><a href="#SoleData.ScalarOneStepRelationalMemoset"><code>SoleData.ScalarOneStepRelationalMemoset</code></a></li><li><a href="#SoleData.ScalarUniversalFormula"><code>SoleData.ScalarUniversalFormula</code></a></li><li><a href="#SoleData.SupportedLogiset"><code>SoleData.SupportedLogiset</code></a></li><li><a href="#SoleData.TestOperator"><code>SoleData.TestOperator</code></a></li><li><a href="#SoleData.UnivariateFeature"><code>SoleData.UnivariateFeature</code></a></li><li><a href="#SoleData.UnivariateNamedFeature"><code>SoleData.UnivariateNamedFeature</code></a></li><li><a href="#SoleData.UnivariateScalarAlphabet"><code>SoleData.UnivariateScalarAlphabet</code></a></li><li><a href="#SoleData.ValueCondition"><code>SoleData.ValueCondition</code></a></li><li><a href="#SoleData.VarFeature"><code>SoleData.VarFeature</code></a></li><li><a href="#SoleData.VariableAvg"><code>SoleData.VariableAvg</code></a></li><li><a href="#SoleData.VariableDistance"><code>SoleData.VariableDistance</code></a></li><li><a href="#SoleData.VariableMax"><code>SoleData.VariableMax</code></a></li><li><a href="#SoleData.VariableMin"><code>SoleData.VariableMin</code></a></li><li><a href="#SoleData.VariableSoftMax"><code>SoleData.VariableSoftMax</code></a></li><li><a href="#SoleData.VariableSoftMin"><code>SoleData.VariableSoftMin</code></a></li><li><a href="#SoleData.VariableValue"><code>SoleData.VariableValue</code></a></li><li><a href="#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a></li><li><a href="#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a></li><li><a href="#SoleLogics.Atom"><code>SoleLogics.Atom</code></a></li><li><a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a></li><li><a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a></li><li><a href="#SoleData.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}"><code>SoleData.apply_test_operator</code></a></li><li><a href="#SoleData.capacity-Tuple{SoleData.AbstractMemoset}"><code>SoleData.capacity</code></a></li><li><a href="#SoleData.checkcondition-Tuple{SoleData.AbstractCondition, Vararg{Any}}"><code>SoleData.checkcondition</code></a></li><li><a href="#SoleData.computefeature-Tuple{VarFeature, Any}"><code>SoleData.computefeature</code></a></li><li><a href="#SoleData.computeunivariatefeature-Union{Tuple{T}, Tuple{VariableDistance, AbstractArray{T}}} where T"><code>SoleData.computeunivariatefeature</code></a></li><li><a href="#SoleData.computeunivariatefeature-Tuple{SoleData.AbstractUnivariateFeature, Any}"><code>SoleData.computeunivariatefeature</code></a></li><li><a href="#SoleData.features-Tuple{SoleData.AbstractLogiset}"><code>SoleData.features</code></a></li><li><a href="#SoleData.featvaltype-Tuple{Any, VarFeature}"><code>SoleData.featvaltype</code></a></li><li><a href="#SoleData.featvalue-Tuple{AbstractFeature, Any, Integer, Any}"><code>SoleData.featvalue</code></a></li><li><a href="#SoleData.initlogiset-Tuple{AbstractVector{&lt;:AbstractArray{T, D}} where {T&lt;:Number, D}, AbstractVector}"><code>SoleData.initlogiset</code></a></li><li><a href="#SoleData.islogiseed-Tuple{Any}"><code>SoleData.islogiseed</code></a></li><li><a href="#SoleData.ismultilogiseed-Tuple{Any}"><code>SoleData.ismultilogiseed</code></a></li><li><a href="#SoleData.minify"><code>SoleData.minify</code></a></li><li><a href="#SoleData.modforms-Tuple{MultiFormula}"><code>SoleData.modforms</code></a></li><li><a href="#SoleData.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}"><code>SoleData.naturalgrouping</code></a></li><li><a href="#SoleData.nfeatures-Tuple{SoleData.AbstractLogiset}"><code>SoleData.nfeatures</code></a></li><li><a href="#SoleData.nmemoizedvalues-Tuple{SoleData.AbstractMemoset}"><code>SoleData.nmemoizedvalues</code></a></li><li><a href="#SoleData.parsecondition-Tuple{Type{&lt;:SoleData.AbstractCondition}, AbstractString}"><code>SoleData.parsecondition</code></a></li><li><a href="#SoleData.parsefeature-Tuple{Type{&lt;:AbstractFeature}, AbstractString}"><code>SoleData.parsefeature</code></a></li><li><a href="#SoleData.parsefeature-Union{Tuple{FT}, Tuple{Type{FT}, AbstractString}} where FT&lt;:VarFeature"><code>SoleData.parsefeature</code></a></li><li><a href="#SoleData.representatives-Union{Tuple{W}, Tuple{AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W&lt;:AbstractWorld"><code>SoleData.representatives</code></a></li><li><a href="#SoleData.scalaralphabet-Tuple{SoleLogics.AbstractAlphabet{&lt;:ScalarCondition}, Vararg{Any}}"><code>SoleData.scalaralphabet</code></a></li><li><a href="#SoleData.scalarlogiset"><code>SoleData.scalarlogiset</code></a></li><li><a href="#SoleData.variable_name-Tuple{SoleData.AbstractUnivariateFeature}"><code>SoleData.variable_name</code></a></li><li><a href="#SoleLogics.accessibles"><code>SoleLogics.accessibles</code></a></li><li><a href="#SoleLogics.alphabet"><code>SoleLogics.alphabet</code></a></li><li><a href="#SoleLogics.check-Union{Tuple{FT}, Tuple{U}, Tuple{W}, Tuple{SoleLogics.CheckAlgorithm, SyntaxBranch, SoleLogics.LogicalInstance{&lt;:SoleData.AbstractModalLogiset{W, var&quot;#s103&quot;, FT, FR} where {var&quot;#s103&quot;&lt;:U, FT&lt;:AbstractFeature, FR&lt;:AbstractFrame{W}}}}, Tuple{SoleLogics.CheckAlgorithm, SyntaxBranch, SoleLogics.LogicalInstance{&lt;:SoleData.AbstractModalLogiset{W, var&quot;#s105&quot;, FT, FR} where {var&quot;#s105&quot;&lt;:U, FT&lt;:AbstractFeature, FR&lt;:AbstractFrame{W}}}, Union{Nothing, SoleLogics.AnyWorld, AbstractWorld}}} where {W&lt;:AbstractWorld, U, FT&lt;:Formula}"><code>SoleLogics.check</code></a></li><li><a href="#SoleLogics.check-Tuple{SoleLogics.CheckAlgorithm, Truth, SoleLogics.LogicalInstance, Vararg{Any}}"><code>SoleLogics.check</code></a></li><li><a href="#SoleLogics.syntaxstring-Tuple{ScalarCondition}"><code>SoleLogics.syntaxstring</code></a></li><li><a href="#SoleLogics.syntaxstring"><code>SoleLogics.syntaxstring</code></a></li><li><a href="#SoleData.@scalarformula-Tuple{Any}"><code>SoleData.@scalarformula</code></a></li></ul><h1 id="Logical-foundations"><a class="docs-heading-anchor" href="#Logical-foundations">Logical foundations</a><a id="Logical-foundations-1"></a><a class="docs-heading-anchor-permalink" href="#Logical-foundations" title="Permalink"></a></h1><p>Here are some core concepts for symbolic artificial intelligence with propositional and modal logics.o</p><article><details class="docstring" open="true"><summary id="SoleLogics.Atom"><a class="docstring-binding" href="#SoleLogics.Atom"><code>SoleLogics.Atom</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Atom{V} &lt;: AbstractAtom
    value::V
end</code></pre><p>Simplest atom implementation, wrapping a <code>value</code>.</p><p>See also <a href="@ref"><code>AbstractAtom</code></a>, <a href="@ref"><code>value</code></a>, <a href="#SoleLogics.check-Tuple{SoleLogics.CheckAlgorithm, Truth, SoleLogics.LogicalInstance, Vararg{Any}}"><code>check</code></a>, <a href="@ref"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/utils/syntactical.jl#L35-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractWorld"><a class="docstring-binding" href="#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractWorld end</code></pre><p>Abstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to <em>worlds</em>, that is, nodes of a graph.</p><p><strong>Implementing</strong></p><p>When implementing a new world type, the logical semantics should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="@ref"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/types/modal-logic.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.Interval"><a class="docstring-binding" href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Interval{T&lt;:Real} &lt;: GeometricalWorld
    x :: T
    y :: T
end</code></pre><p>An interval in a 1-dimensional space, with coordinates of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),1)
true

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval(1,2),2)
false

julia&gt; collect(accessibles(FullDimensionalFrame(5), Interval(1,2), SoleLogics.IA_L))
6-element Vector{Interval{Int64}}:
 (3−4)
 (3−5)
 (4−5)
 (3−6)
 (4−6)
 (5−6)

</code></pre><p>See also <a href="@ref"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles"><code>accessibles</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval2D"><code>Interval2D</code></a>, <a href="@ref"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/utils/frames/worlds/geometrical-worlds.jl#L88-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.Interval2D"><a class="docstring-binding" href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Interval2D{T&lt;:Real} &lt;: GeometricalWorld
    x :: Interval{T}
    y :: Interval{T}
end</code></pre><p>A orthogonal rectangle in a 2-dimensional space, with coordinates of type <code>T</code>. This is the 2-dimensional <code>Interval</code> counterpart, that is, the combination of two orthogonal <code>Interval</code>s.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),1)
false

julia&gt; SoleLogics.goeswithdim(SoleLogics.Interval2D((1,2),(3,4)),2)
true

julia&gt; collect(accessibles(FullDimensionalFrame(5,5), Interval2D((2,3),(2,4)), SoleLogics.IA_LL))
3-element Vector{Interval2D{Int64}}:
 ((4−5)×(5−6))
 ((4−6)×(5−6))
 ((5−6)×(5−6))
</code></pre><p>See also <a href="@ref"><code>goeswithdim</code></a>, <a href="#SoleLogics.accessibles"><code>accessibles</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="@ref"><code>Point</code></a>, <a href="#SoleLogics.Interval"><code>Interval</code></a>, <a href="@ref"><code>GeometricalWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/utils/frames/worlds/geometrical-worlds.jl#L150-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.syntaxstring"><a class="docstring-binding" href="#SoleLogics.syntaxstring"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">syntaxstring(m::ScalarCondition; 
            style=false, removewhitespaces::Bool=false, 
            pretty_op::Bool=true, kwargs...)::String</code></pre><p>Generate a formatted string representation of a feature, test operator and threshold combination.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>threshold_digits::Union{Nothing,Integer}=nothing</code>: If set, rounds the threshold value to the specified number of digits (via <code>round(...; digits=threshold_digits)</code>).</li><li><code>threshold_display_method::Union{Nothing,Base.Callable}=nothing</code>: A function applied to the threshold value before string conversion. If provided, it takes precedence over <code>threshold_digits</code>.</li><li><code>style::Union{Bool,Dict}=false</code>: Style options for formatting. If a dict with key  <code>:featurestyle</code> is provided, applies styling (<code>:bold</code> supported). Default <code>false</code> means no styling.</li><li><code>removewhitespaces::Bool=false</code>: If <code>true</code>, removes spaces between feature, operator and threshold.  Useful for generating output suitable for PLA (Programmable Logic Array) applications. Default is <code>false</code> (includes space).</li><li><code>kwargs...</code>: Additional keyword arguments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L299-L317">source</a></section><section><div><pre><code class="language-julia hljs">syntaxstring(s::Syntactical; kwargs...)::String</code></pre><p>Return the string representation of any syntactic object (e.g., <code>Formula</code>, <code>SyntaxTree</code>, <code>SyntaxToken</code>, <code>Atom</code>, <code>Truth</code>, etc). Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leaves of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(∧(∧(∧(p, q), r), s), t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="@ref"><code>parseformula</code></a>, <a href="@ref"><code>SyntaxBranch</code></a>, <a href="@ref"><code>SyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including the <code>kwargs...</code> part!) for every newly defined <code>SyntaxToken</code> (e.g., <code>SyntaxLeaf</code>s, that is, <code>Atom</code>s and <code>Truth</code> values, and <code>Operator</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxTree</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)</code></pre><p>The <code>syntaxstring</code> for any value defaults to its <code>string</code> representation, but it can be defined by defining the appropriate <code>syntaxstring</code> method.</p><div class="admonition is-warning" id="Warning-2a5cf465b6c8e951"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2a5cf465b6c8e951" title="Permalink"></a></header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>).</p></div></div><p>See also <a href="@ref"><code>SyntaxLeaf</code></a>, <a href="@ref"><code>Operator</code></a>, <a href="@ref"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/types/syntactical.jl#L37-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.IA_L"><a class="docstring-binding" href="#SoleLogics.IA_L"><code>SoleLogics.IA_L</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>See <a href="@ref"><code>IntervalRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/utils/frames/relations/IntervalAlgebra.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractFrame"><a class="docstring-binding" href="#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractFrame{W&lt;:AbstractWorld} end</code></pre><p>Abstract type for an accessibility graph (Kripke frame), that gives the topology to <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>. A frame can be queried for its set of vertices (also called <em>worlds</em>, see <a href="@ref"><code>allworlds</code></a>), and it can be browsed via its accessibility relation(s) (see <a href="#SoleLogics.accessibles"><code>accessibles</code></a>). Refer to <a href="@ref"><code>FullDimensionalFrame</code></a> as an example.</p><p>See also <a href="@ref"><code>truthtype</code></a>, , <a href="@ref"><code>allworlds</code></a>, <a href="@ref"><code>nworlds</code></a>, <a href="@ref"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/types/modal-logic.jl#L25-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.accessibles"><a class="docstring-binding" href="#SoleLogics.accessibles"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="@ref"><code>AbstractUniModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/types/modal-logic.jl#L88-L94">source</a></section><section><div><pre><code class="language-julia hljs">accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation
) where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code> via relation <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = FullDimensionalFrame((10,), Interval{Int});

julia&gt; typeof(accessibles(fr, Interval(2,5), IA_L))
Base.Generator{...}

julia&gt; typeof(accessibles(fr, globalrel))
Base.Generator{...}

julia&gt; @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))

julia&gt; typeof(accessibles(fr, Interval(2,5), identityrel))
Vector{Interval{Int64}}

julia&gt; Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>Since <code>accessibles</code> always returns an iterator to worlds of the same type <code>W</code>, the current implementation of <code>accessibles</code> for multi-modal frames delegates the enumeration to a lower level <code>_accessibles</code> function, which returns an iterator to parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:</p><pre><code class="nohighlight hljs">function accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    IterTools.imap(W, _accessibles(fr, w, r))
end</code></pre><p>As such, when defining new frames, worlds, and/or relations, one should provide new methods for <code>_accessibles</code>. For example:</p><pre><code class="nohighlight hljs">_accessibles(fr::Full1DFrame, w::Interval{&lt;:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)</code></pre><p>This pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type <code>FR{W}</code>, one can resolve the ambiguities and define a custom <code>accessibles</code> method by providing these three methods:</p><pre><code class="nohighlight hljs"># access worlds through relation `r`
function accessibles(
    fr::FR{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    ...
end

# access current world
function accessibles(
    fr::FR{W},
    w::W,
    r::IdentityRel,
) where {W&lt;:AbstractWorld}
    [w]
end

# access all worlds
function accessibles(
    fr::FR{W},
    w::W,
    r::GlobalRel,
) where {W&lt;:AbstractWorld}
    allworlds(fr)
end</code></pre><p>In general, it should be true that <code>collect(accessibles(fr, w, r)) isa AbstractWorlds{W}</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="@ref"><code>AbstractRelation</code></a>, <a href="@ref"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/v0.13.7/src/types/modal-logic.jl#L265-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.minify"><a class="docstring-binding" href="#SoleData.minify"><code>SoleData.minify</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">minify(dataset::D1)::Tuple{D2,Function} where {D1,D2}</code></pre><p>Return a <em>minified</em> version of a dataset, as well as a backmap for reverting to the original dataset. Dataset minification remaps each scalar values in the dataset to a new value such that the overall order of the values is preserved; the output dataset is smaller in size, since it relies on values of type UInt8, UInt16, UInt32, etc.</p><p>See also <a href="@ref"><code>isminifiable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/minify.jl#L10-L21">source</a></section></details></article><p>See <a href="https://github.com/aclai-lab/SoleLogics.jl">SoleLogics</a> for more.</p><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Ontop of the logical layer, we define features, conditions on features, logisets, and memosets.</p><article><details class="docstring" open="true"><summary id="SoleData.AbstractFeature"><a class="docstring-binding" href="#SoleData.AbstractFeature"><code>SoleData.AbstractFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractFeature end</code></pre><p>Abstract type for features of worlds of [Kripke structures](https://en.wikipedia.org/wiki/Kripke<em>structure</em>(model_checking).</p><p>See also <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.featvaltype-Tuple{Any, VarFeature}"><code>featvaltype</code></a>, <a href="#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/features.jl#L4-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.parsefeature-Tuple{Type{&lt;:AbstractFeature}, AbstractString}"><a class="docstring-binding" href="#SoleData.parsefeature-Tuple{Type{&lt;:AbstractFeature}, AbstractString}"><code>SoleData.parsefeature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsefeature(FT::Type{&lt;:AbstractFeature}, expr::AbstractString; kwargs...)</code></pre><p>Parse a feature of type <code>FT</code> from its <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a> representation. Depending on <code>FT</code>, specifying keyword arguments such as <code>featvaltype::Type</code> may be required or recommended.</p><p>See also <a href="#SoleData.parsecondition-Tuple{Type{&lt;:SoleData.AbstractCondition}, AbstractString}"><code>parsecondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/features.jl#L36-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractCondition"><a class="docstring-binding" href="#SoleData.AbstractCondition"><code>SoleData.AbstractCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractCondition{FT&lt;:AbstractFeature} end</code></pre><p>Abstract type for representing conditions that can be interpreted and evaluated on worlds of instances of a logical dataset. In logical contexts, these are wrapped into <code>Atom</code>s.</p><p>See also <a href="#SoleLogics.Atom"><code>Atom</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>, <a href="#SoleData.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/conditions.jl#L10-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.checkcondition-Tuple{SoleData.AbstractCondition, Vararg{Any}}"><a class="docstring-binding" href="#SoleData.checkcondition-Tuple{SoleData.AbstractCondition, Vararg{Any}}"><code>SoleData.checkcondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkcondition(c::AbstractCondition, args...; kwargs...)</code></pre><p>Check a condition (e.g., on a world of a logiset instance).</p><p>This function must be implemented for each subtype of <code>AbstractCondition</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Checking a condition on a logiset created from a DataFrame
using SoleData, DataFrames

# Load the iris dataset
iris_df = DataFrame(load_iris());

# Convert the DataFrame to a logiset
iris_logiset = scalarlogiset(iris_df);

# Create a ScalarCondition
condition = ScalarCondition(:sepal_length, &gt;, 5.0);

# Check the condition on the logiset
@assert checkcondition(condition, iris_logiset, 1) == true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/conditions.jl#L25-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.parsecondition-Tuple{Type{&lt;:SoleData.AbstractCondition}, AbstractString}"><a class="docstring-binding" href="#SoleData.parsecondition-Tuple{Type{&lt;:SoleData.AbstractCondition}, AbstractString}"><code>SoleData.parsecondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsecondition(C::Type{&lt;:AbstractCondition}, expr::AbstractString; kwargs...)</code></pre><p>Parse a condition of type <code>C</code> from its <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a> representation. Depending on <code>C</code>, specifying keyword arguments such as <code>featuretype::Type{&lt;:AbstractFeature}</code>, and <code>featvaltype::Type</code> may be required or recommended.</p><p>See also <a href="#SoleData.parsefeature-Tuple{Type{&lt;:AbstractFeature}, AbstractString}"><code>parsefeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/conditions.jl#L76-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractLogiset"><a class="docstring-binding" href="#SoleData.AbstractLogiset"><code>SoleData.AbstractLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractLogiset &lt;: AbstractInterpretationSet end</code></pre><p>Abstract type for logisets, that is, sets of logical interpretations onto which (formulas on) conditions can be checked.</p><p>See also <a href="#SoleData.AbstractCondition"><code>AbstractCondition</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>, <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/logiset.jl#L12-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.features-Tuple{SoleData.AbstractLogiset}"><a class="docstring-binding" href="#SoleData.features-Tuple{SoleData.AbstractLogiset}"><code>SoleData.features</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the number of features for which instances in a logiset have value. Note that the set of features is not always defined for all logiset types.</p><p>See also <a href="#SoleData.AbstractLogiset"><code>AbstractLogiset</code></a>, <a href="#SoleData.featvalue-Tuple{AbstractFeature, Any, Integer, Any}"><code>featvalue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/logiset.jl#L81-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.nfeatures-Tuple{SoleData.AbstractLogiset}"><a class="docstring-binding" href="#SoleData.nfeatures-Tuple{SoleData.AbstractLogiset}"><code>SoleData.nfeatures</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the number of features in a logiset (if defined).</p><p>See also <a href="#SoleData.features-Tuple{SoleData.AbstractLogiset}"><code>features</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/logiset.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractFullMemoset"><a class="docstring-binding" href="#SoleData.AbstractFullMemoset"><code>SoleData.AbstractFullMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for full memoization structures for checking generic formulas.</p><p>These structures can be stacked and coupled with <em>one-step</em> memoization structures (see <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>).</p><p>See <a href="#SoleData.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>, <a href="#SoleData.FullMemoset"><code>FullMemoset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/memoset.jl#L102-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractMemoset"><a class="docstring-binding" href="#SoleData.AbstractMemoset"><code>SoleData.AbstractMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractMemoset{
    W&lt;:AbstractWorld,
    U,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame,
} &lt;: AbstractModalLogiset{W,U,FT,FR} end</code></pre><p>Abstract type for memoization structures to be used when checking formulas on logisets.</p><p>See also <a href="#SoleData.FullMemoset"><code>FullMemoset</code></a>, <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/memoset.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractOneStepMemoset"><a class="docstring-binding" href="#SoleData.AbstractOneStepMemoset"><code>SoleData.AbstractOneStepMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for one-step memoization structures for checking formulas of type <code>⟨R⟩p</code>; with these formulas, so-called &quot;one-step&quot; optimizations can be performed.</p><p>These structures can be stacked and coupled with <em>full</em> memoization structures (see <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>).</p><p>See <a href="#SoleData.ScalarOneStepMemoset"><code>ScalarOneStepMemoset</code></a>, <a href="#SoleData.AbstractFullMemoset"><code>AbstractFullMemoset</code></a>, <a href="#SoleData.representatives-Union{Tuple{W}, Tuple{AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W&lt;:AbstractWorld"><code>representatives</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/memoset.jl#L91-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.capacity-Tuple{SoleData.AbstractMemoset}"><a class="docstring-binding" href="#SoleData.capacity-Tuple{SoleData.AbstractMemoset}"><code>SoleData.capacity</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the capacity of a memoset, that is, the number of memoizable values (if finite).</p><p>See also <a href="#SoleData.AbstractMemoset"><code>AbstractMemoset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/memoset.jl#L24-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.nmemoizedvalues-Tuple{SoleData.AbstractMemoset}"><a class="docstring-binding" href="#SoleData.nmemoizedvalues-Tuple{SoleData.AbstractMemoset}"><code>SoleData.nmemoizedvalues</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the number of memoized values in a memoset.</p><p>See also <a href="#SoleData.AbstractMemoset"><code>AbstractMemoset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/memoset.jl#L34-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractModalLogiset"><a class="docstring-binding" href="#SoleData.AbstractModalLogiset"><code>SoleData.AbstractModalLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractModalLogiset{
    W&lt;:AbstractWorld,
    U,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractLogiset end</code></pre><p>Abstract type for logisets, that is, logical datasets for symbolic learning where each instance is a <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structure</a> associating feature values to each world. Conditions (see <a href="#SoleData.AbstractCondition"><code>AbstractCondition</code></a>), and logical formulas with conditional letters can be checked on worlds of instances of the dataset.</p><p><strong>Interface</strong></p><ul><li><code>readfeature(X::AbstractModalLogiset, featchannel::Any, w::W, feature::AbstractFeature)</code></li><li><code>featchannel(X::AbstractModalLogiset, i_instance::Integer, feature::AbstractFeature)</code></li><li><code>featvalue(feature::AbstractFeature, X::AbstractModalLogiset, i_instance::Integer, args...; kwargs...)</code></li><li><code>featvalue!(feature::AbstractFeature, X::AbstractModalLogiset{W}, featval, i_instance::Integer, w::W)</code></li><li><code>featvalues!(feature::AbstractFeature, X::AbstractModalLogiset{W}, featslice)</code></li><li><code>frametype(X::AbstractModalLogiset)</code></li><li><code>worldtype(X::AbstractModalLogiset)</code></li></ul><p>See also <a href="#SoleData.AbstractCondition"><code>AbstractCondition</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>, <a href="@ref"><code>SoleLogics.AbstractKripkeStructure</code></a>, <a href="@ref"><code>SoleLogics.AbstractInterpretationSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/modal-logiset.jl#L5-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractScalarOneStepRelationalMemoset"><a class="docstring-binding" href="#SoleData.AbstractScalarOneStepRelationalMemoset"><code>SoleData.AbstractScalarOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for one-step memoization structures for checking formulas of type <code>⟨R⟩ (f ⋈ t)</code>, for a generic relation <code>R</code> that is not the global relation (<a href="@ref"><code>SoleLogics.globalrel</code></a>). We refer to these structures as <em>relational memosets</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/onestep-memoset.jl#L88-L92">source</a></section></details></article><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><h2 id="Logisets"><a class="docs-heading-anchor" href="#Logisets">Logisets</a><a id="Logisets-1"></a><a class="docs-heading-anchor-permalink" href="#Logisets" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleData.ExplicitFeature"><a class="docstring-binding" href="#SoleData.ExplicitFeature"><code>SoleData.ExplicitFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ExplicitFeature{T} &lt;: AbstractFeature
    name::String
    featstruct
end</code></pre><p>A feature encoded explicitly, for example, as a slice of <a href="#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><code>DimensionalDatasets.UniformFullDimensionalLogiset</code></a>&#39;s feature structure.</p><p>See also <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/features.jl#L39-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.Feature"><a class="docstring-binding" href="#SoleData.Feature"><code>SoleData.Feature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Feature{A} &lt;: AbstractFeature
    atom::A
end</code></pre><p>A feature solely identified by an atom (e.g., a string with its name, a tuple of strings, etc.)</p><p>See also <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/features.jl#L6-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.FunctionalCondition"><a class="docstring-binding" href="#SoleData.FunctionalCondition"><code>SoleData.FunctionalCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FunctionalCondition{FT&lt;:AbstractFeature} &lt;: AbstractCondition{FT}
    feature::FT
    f::FT
end</code></pre><p>A condition which yields a truth value equal to the value of a function.</p><p>See also <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/conditions.jl#L32-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ValueCondition"><a class="docstring-binding" href="#SoleData.ValueCondition"><code>SoleData.ValueCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ValueCondition{FT&lt;:AbstractFeature} &lt;: AbstractCondition{FT}
    feature::FT
end</code></pre><p>A condition which yields a truth value equal to the value of a feature.</p><p>See also <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/conditions.jl#L4-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ExplicitBooleanModalLogiset"><a class="docstring-binding" href="#SoleData.ExplicitBooleanModalLogiset"><code>SoleData.ExplicitBooleanModalLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ExplicitBooleanModalLogiset{
    W&lt;:AbstractWorld,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractModalLogiset{W,Bool,FT,FR}

    d :: Vector{Tuple{Dict{W,Vector{FT}},FR}}

end</code></pre><p>A logiset where the features are boolean, and where each instance associates to each world the set of features with <code>true</code>.</p><p>See also <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/modal-logiset.jl#L25-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ExplicitModalLogiset"><a class="docstring-binding" href="#SoleData.ExplicitModalLogiset"><code>SoleData.ExplicitModalLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ExplicitModalLogiset{
    W&lt;:AbstractWorld,
    U,
    FT&lt;:AbstractFeature,
    FR&lt;:AbstractFrame{W},
} &lt;: AbstractModalLogiset{W,U,FT,FR}

    d :: Vector{Tuple{Dict{W,Dict{FT,U}},FR}}

end</code></pre><p>A logiset where the features are boolean, and where each instance associates to each world the set of features with <code>true</code>.</p><p>See also <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/modal-logiset.jl#L163-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.FullMemoset"><a class="docstring-binding" href="#SoleData.FullMemoset"><code>SoleData.FullMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A generic, full memoization structure that works for any <em>crisp</em> logic; For each instance of a dataset, this structure associates formulas to the set of worlds where the formula holds; it was introduced by Emerson-Clarke for the well-known model checking algorithm for CTL*.</p><p>See also <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleData.AbstractMemoset"><code>AbstractMemoset</code></a>, <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/memoset.jl#L4-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarOneStepMemoset"><a class="docstring-binding" href="#SoleData.ScalarOneStepMemoset"><code>SoleData.ScalarOneStepMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>One-step memoization structures for optimized check of formulas of type <code>⟨R⟩p</code>, where <code>p</code> wraps a scalar condition, such as <code>MyFeature ≥ 10</code>. With such formulas, scalar one-step optimization can be performed.</p><p>For example, checking <code>⟨R⟩(MyFeature ≥ 10)</code> on a world <code>w</code> of a Kripke structure involves comparing the <em>maximum</em> MyFeature across <code>w</code>s accessible worlds with 10; but the same <em>maximum</em> value can be reused to check <em>sibling formulas</em> such as <code>⟨R⟩(MyFeature ≥ 100)</code>. This sparks the idea of storing and reusing scalar aggregations (e.g., minimum/maximum) over the feature values. Each value refers to a specific world, and an object of type <code>⟨R⟩(f ⋈ ?)</code>, called a &quot;scalar <em>metacondition</em>&quot;.</p><p>Similar cases arise depending on the relation and the test operator (or, better, its <em>aggregator</em>), and further optimizations can be applied for specific feature types (see <a href="#SoleData.representatives-Union{Tuple{W}, Tuple{AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W&lt;:AbstractWorld"><code>representatives</code></a>).</p><p>An immediate special case, however, arises when <code>R</code> is the global relation <code>G</code> since, in such case, a single aggregate value is enough for all worlds within the Kripke structure. Therefore, we differentiate between generic, <em>relational</em> memosets (see <a href="#SoleData.AbstractScalarOneStepRelationalMemoset"><code>AbstractScalarOneStepRelationalMemoset</code></a>), and <em>global</em> memosets (see <a href="#SoleData.AbstractScalarOneStepGlobalMemoset"><code>AbstractScalarOneStepGlobalMemoset</code></a>), which are usually much smaller.</p><p>Given a logiset <code>X</code>, a <code>ScalarOneStepMemoset</code> covers a set of <code>relations</code> and <code>metaconditions</code>, and it holds both a <em>relational</em> and a <em>global</em> memoset. It can be instantiated via:</p><pre><code class="language-julia hljs">ScalarOneStepMemoset(
    X                       :: AbstractModalLogiset{W,U},
    metaconditions          :: AbstractVector{&lt;:ScalarMetaCondition},
    relations               :: AbstractVector{&lt;:AbstractRelation};
    precompute_globmemoset  :: Bool = true,
    precompute_relmemoset   :: Bool = false,
    print_progress          :: Bool = false,
)</code></pre><p>If <code>precompute_relmemoset</code> is <code>false</code>, then the relational memoset is simply initialized as an empty structure, and memoization is performed on it upon checking formulas. <code>precompute_globmemoset</code> works similarly.</p><p>See <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleData.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>, <a href="#SoleData.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/onestep-memoset.jl#L180-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.SupportedLogiset"><a class="docstring-binding" href="#SoleData.SupportedLogiset"><code>SoleData.SupportedLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A logiset, associated to a number of cascading full or one-step memoization structures, that are used for optimizing the checking of formulas.</p><p>See also <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>, <a href="#SoleData.AbstractFullMemoset"><code>AbstractFullMemoset</code></a>, <a href="#SoleData.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>, <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/supported-logiset.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.check-Tuple{SoleLogics.CheckAlgorithm, Truth, SoleLogics.LogicalInstance, Vararg{Any}}"><a class="docstring-binding" href="#SoleLogics.check-Tuple{SoleLogics.CheckAlgorithm, Truth, SoleLogics.LogicalInstance, Vararg{Any}}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check(
    ::CheckAlgorithm,
    φ::Truth,
    i::LogicalInstance,
    args...;
    kwargs...
)::Bool</code></pre><p>Check whether a <code>Truth</code> formula holds for a given instance.</p><p>Note: This method provides a specialized implementation for <code>Truth</code> and <code>BooleanTruth</code>  types from SoleLogics. Since these types inherit from the <code>Formula</code> supertype defined  in SoleLogics, they require their own method definition here rather than falling back  to the <code>Formula</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/check.jl#L190-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.check-Union{Tuple{FT}, Tuple{U}, Tuple{W}, Tuple{SoleLogics.CheckAlgorithm, SyntaxBranch, SoleLogics.LogicalInstance{&lt;:SoleData.AbstractModalLogiset{W, var&quot;#s103&quot;, FT, FR} where {var&quot;#s103&quot;&lt;:U, FT&lt;:AbstractFeature, FR&lt;:AbstractFrame{W}}}}, Tuple{SoleLogics.CheckAlgorithm, SyntaxBranch, SoleLogics.LogicalInstance{&lt;:SoleData.AbstractModalLogiset{W, var&quot;#s105&quot;, FT, FR} where {var&quot;#s105&quot;&lt;:U, FT&lt;:AbstractFeature, FR&lt;:AbstractFrame{W}}}, Union{Nothing, SoleLogics.AnyWorld, AbstractWorld}}} where {W&lt;:AbstractWorld, U, FT&lt;:Formula}"><a class="docstring-binding" href="#SoleLogics.check-Union{Tuple{FT}, Tuple{U}, Tuple{W}, Tuple{SoleLogics.CheckAlgorithm, SyntaxBranch, SoleLogics.LogicalInstance{&lt;:SoleData.AbstractModalLogiset{W, var&quot;#s103&quot;, FT, FR} where {var&quot;#s103&quot;&lt;:U, FT&lt;:AbstractFeature, FR&lt;:AbstractFrame{W}}}}, Tuple{SoleLogics.CheckAlgorithm, SyntaxBranch, SoleLogics.LogicalInstance{&lt;:SoleData.AbstractModalLogiset{W, var&quot;#s105&quot;, FT, FR} where {var&quot;#s105&quot;&lt;:U, FT&lt;:AbstractFeature, FR&lt;:AbstractFrame{W}}}, Union{Nothing, SoleLogics.AnyWorld, AbstractWorld}}} where {W&lt;:AbstractWorld, U, FT&lt;:Formula}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check(
    ::CheckAlgorithm,
    φ::SoleLogics.SyntaxTree,
    i::SoleLogics.LogicalInstance{&lt;:AbstractModalLogiset{W,&lt;:U}},
    w::Union{Nothing,AnyWorld,&lt;:AbstractWorld} = nothing;
    kwargs...
)::Bool</code></pre><p>Check whether a formula <code>φ</code> holds for a given instance <code>i_instance</code> of a logiset <code>X</code>, on a world <code>w</code>. Note that the world can be elided for grounded formulas (see <a href="@ref"><code>isgrounded</code></a>).</p><p>This implementation recursively evaluates the subformulas of <code>φ</code> and use memoization to store the results using Emerson-Clarke algorithm. The memoization structure is either the one stored in <code>X</code> itself (if <code>X</code> supports memoization) or a structure passed as the <code>use_memo</code> argument. If <code>X</code> supports onestep memoization, then it will be used for specific diamond formulas, up to an height equal to a keyword argument <code>memo_max_height</code>.</p><p><strong>Arguments</strong></p><ul><li><code>φ::SoleLogics.SyntaxTree</code>: the formula to check.</li><li><code>i::SoleLogics.LogicalInstance{&lt;:AbstractModalLogiset{W,&lt;:U}}</code>: the instance of the logiset to check in.</li><li><code>w::Union{Nothing,AnyWorld,&lt;:AbstractWorld} = nothing</code>: the world to check in. If <code>nothing</code>, the method checks in all worlds of the instance.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>use_memo::Union{Nothing,AbstractMemoset{&lt;:AbstractWorld},AbstractVector{&lt;:AbstractDict{&lt;:FT,&lt;:AbstractWorlds}}} = nothing</code>: the memoization structure to use. If <code>nothing</code>, the method uses the one stored in <code>X</code> if <code>X</code> supports memoization. If <code>AbstractMemoset</code>, the method uses the <code>i_instance</code>-th element of the memoization structure. If <code>AbstractVector</code>, the method uses the <code>i_instance</code>-th element of the vector.</li><li><code>perform_normalization::Bool = true</code>: whether to normalize the formula before checking it.</li><li><code>memo_max_height::Union{Nothing,Int} = nothing</code>: the maximum height up to which onestep memoization should be used. If <code>nothing</code>, the method does not use onestep memoization.</li><li><code>onestep_memoset_is_complete = false</code>: whether the onestep memoization structure is complete (i.e. it contains all possible values of the metaconditions in the structure).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/check.jl#L33-L60">source</a></section></details></article><h3 id="Scalar-Logisets"><a class="docs-heading-anchor" href="#Scalar-Logisets">Scalar Logisets</a><a id="Scalar-Logisets-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Logisets" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SoleData.MixedCondition"><a class="docstring-binding" href="#SoleData.MixedCondition"><code>SoleData.MixedCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A union type for all condition-inducing objects. An object of this type, coupled with a (e.g., dimensional) dataset will induce a set of conditions in <a href="#SoleData.scalarlogiset"><code>scalarlogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/main.jl#L29-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.@scalarformula-Tuple{Any}"><a class="docstring-binding" href="#SoleData.@scalarformula-Tuple{Any}"><code>SoleData.@scalarformula</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@scalarformula expr</code></pre><p>Parse a logical formula on scalar conditions, such as <code>V1 &gt; 10</code>. Note that logical operators take precedence over comparison operators, so it is often the case that expressions such as <code>V1 &gt; 10</code> must be wrapped in parentheses.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; φ = @scalarformula ((V1 &gt; 10) ∧ (V2 &lt; 0) ∧ (V2 &lt; 0) ∧ (V2 &lt;= 0)) ∨ ((V1 &lt;= 0) ∧ ((V1 &lt;= 3)) ∧ (V2 &gt;= 2))
SyntaxBranch: (V1 &gt; 10 ∧ V2 &lt; 0 ∧ V2 &lt; 0 ∧ V2 ≤ 0) ∨ (V1 ≤ 0 ∧ V1 ≤ 3 ∧ V2 ≥ 2)</code></pre><p>See also <a href="@ref"><code>parseformula</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/scalarformula.jl#L7-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.BASE_FEATURE_FUNCTIONS_ALIASES"><a class="docstring-binding" href="#SoleData.BASE_FEATURE_FUNCTIONS_ALIASES"><code>SoleData.BASE_FEATURE_FUNCTIONS_ALIASES</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Syntaxstring aliases for standard features, such as &quot;min&quot;, &quot;max&quot;, &quot;avg&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L599-L601">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractUnivariateFeature"><a class="docstring-binding" href="#SoleData.AbstractUnivariateFeature"><code>SoleData.AbstractUnivariateFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractUnivariateFeature &lt;: VarFeature end</code></pre><p>A dimensional feature represented by the application of a function to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a <code>Interval2D</code> world, when interpreted on an image, contains.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.UnivariateFeature"><code>UnivariateFeature</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L96-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.MultivariateFeature"><a class="docstring-binding" href="#SoleData.MultivariateFeature"><code>SoleData.MultivariateFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MultivariateFeature{U} &lt;: VarFeature
    f::Function
end</code></pre><p>A dimensional feature represented by the application of a function to a dimensional channel. For example, it can wrap a scalar function computing how much a <code>Interval2D</code> world, when interpreted on an image, resembles a horse. Note that the image has a number of spatial variables (3, for the case of RGB), and &quot;resembling a horse&quot; may require a computation involving all variables.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L69-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.UnivariateFeature"><a class="docstring-binding" href="#SoleData.UnivariateFeature"><code>SoleData.UnivariateFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct UnivariateFeature{U,I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
    f::Function
    fname::Union{Nothing,String}
end</code></pre><p>A dimensional feature represented by the application of a generic function <code>f</code> to a single variable of a dimensional channel. For example, it can wrap a scalar function computing how much red a <code>Interval2D</code> world, when interpreted on an image, contains. Optionally, a feature name <code>fname</code> can be attached to the function, which can be useful for inspection (e.g., if <code>f</code> is an anonymous function, this avoids names such s &quot;#47&quot; or &quot;#49&quot;.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L192-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.UnivariateNamedFeature"><a class="docstring-binding" href="#SoleData.UnivariateNamedFeature"><code>SoleData.UnivariateNamedFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct UnivariateNamedFeature{U&lt;:Real,I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
    name::VariableName
end</code></pre><p>A univariate feature solely identified by its name and reference variable.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L232-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VarFeature"><a class="docstring-binding" href="#SoleData.VarFeature"><code>SoleData.VarFeature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type VarFeature &lt;: AbstractFeature end</code></pre><p>Abstract type for feature functions that can be computed on (multi)variate data. Instances of multivariate datasets have values for a number of <em>variables</em>, which can be used to define logical features.</p><p>For example, with dimensional data (e.g., multivariate time series, digital images and videos), features can be computed as the minimum value for a given variable on a specific interval/rectangle/cuboid (in general, a <a href="@ref"><code>SoleLogics.GeometricalWorld</code></a>).</p><p>As an example of a dimensional feature, consider <em>min[V1]</em>, which computes the minimum for variable 1 for a given world. <code>ScalarCondition</code>s such as <em>min[V1] &gt;= 10</em> can be, then, evaluated on worlds.</p><p>See also <a href="#SoleData.scalarlogiset"><code>scalarlogiset</code></a>, <a href="#SoleData.featvaltype-Tuple{Any, VarFeature}"><code>featvaltype</code></a>, <a href="#SoleData.computefeature-Tuple{VarFeature, Any}"><code>computefeature</code></a>, <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L14-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableAvg"><a class="docstring-binding" href="#SoleData.VariableAvg"><code>SoleData.VariableAvg</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableAvg{I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
end</code></pre><p>Univariate feature computing the average value for a given variable.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VariableMax"><code>VariableMax</code></a>, <a href="#SoleData.VariableMin"><code>VariableMin</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L451-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableDistance"><a class="docstring-binding" href="#SoleData.VariableDistance"><code>SoleData.VariableDistance</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableDistance{I&lt;:VariableId,T} &lt;: AbstractUnivariateFeature
    i_variable::I
    references::Vector{&lt;:T}
    distance::Function
    featurename::VariableName
end</code></pre><p>Univariate feature computing a distance function for a given variable, with respect to all</p><p>By default, <code>distance</code> is set to be Euclidean distance and the lowest result is considered.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># we only want to perform comparisons with one important representative signal;
# we call such signal a reference, and encapsulate it within an array.
julia&gt; vd = VariableDistance(1, [[1,2,3,4]]; featurename=&quot;StrictMonotonicAscending&quot;);

julia&gt; syntaxstring(vd)
&quot;StrictMonotonicAscending[V1]&quot;

# compute the distance (euclidean by default) with the given signal
julia&gt; computeunivariatefeature(vd, [1,2,3,4])
0.0

julia&gt; computeunivariatefeature(vd, [2,3,4,5])
2.0

# now we consider multiple references
julia&gt; vd = VariableDistance(1, [
        [0.1,1.8,3.0,3.2],
        [1.1,1.3,2.3,3.8],
        [0.8,1.4,2.5,4.1]
    ];
    featurename=&quot;StrictMonotonicAscending&quot;
);

# return only the minimum distance w.r.t. all the references wrapped within vd
julia&gt; computeunivariatefeature(vd, [1,2,3,4])
0.812403840463596

# we ask for the size of a generic reference
julia&gt; refsize(vd)
(4,)
</code></pre><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VariableMax"><code>VariableMax</code></a>, <a href="#SoleData.VariableMin"><code>VariableMin</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L481-L533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableMax"><a class="docstring-binding" href="#SoleData.VariableMax"><code>SoleData.VariableMax</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableMax{I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
end</code></pre><p>Notable univariate feature computing the maximum value for a given variable.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VariableMin"><code>VariableMin</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L353-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableMin"><a class="docstring-binding" href="#SoleData.VariableMin"><code>SoleData.VariableMin</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableMin{I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
end</code></pre><p>Notable univariate feature computing the minimum value for a given variable.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VariableMax"><code>VariableMax</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L325-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableSoftMax"><a class="docstring-binding" href="#SoleData.VariableSoftMax"><code>SoleData.VariableSoftMax</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableSoftMax{T&lt;:AbstractFloat,I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
    alpha::T
end</code></pre><p>Univariate feature computing a &quot;softened&quot; version of the maximum value for a given variable.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VariableMax"><code>VariableMax</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L416-L429">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableSoftMin"><a class="docstring-binding" href="#SoleData.VariableSoftMin"><code>SoleData.VariableSoftMin</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableSoftMin{T&lt;:AbstractFloat,I&lt;:VariableId} &lt;: AbstractUnivariateFeature
    i_variable::I
    alpha::T
end</code></pre><p>Univariate feature computing a &quot;softened&quot; version of the minimum value for a given variable.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VariableMin"><code>VariableMin</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L383-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.VariableValue"><a class="docstring-binding" href="#SoleData.VariableValue"><code>SoleData.VariableValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VariableValue{I&lt;:VariableId, N&lt;:Union{VariableName, Nothing}} &lt;: AbstractUnivariateFeature
    i_variable::I
    i_name::N
end</code></pre><p>A simple feature, equal the value of a scalar variable and, optionally, its name.</p><p>See also <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a>, <a href="#SoleLogics.Interval2D"><code>SoleLogics.Interval2D</code></a>, <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.AbstractFeature"><code>AbstractFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L276-L288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.computefeature-Tuple{VarFeature, Any}"><a class="docstring-binding" href="#SoleData.computefeature-Tuple{VarFeature, Any}"><code>SoleData.computefeature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">computefeature(f::VarFeature, featchannel; kwargs...)</code></pre><p>Compute a feature on a featchannel (i.e., world reading) of an instance.</p><p>See also <a href="#SoleData.VarFeature"><code>VarFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L53-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.computeunivariatefeature-Tuple{SoleData.AbstractUnivariateFeature, Any}"><a class="docstring-binding" href="#SoleData.computeunivariatefeature-Tuple{SoleData.AbstractUnivariateFeature, Any}"><code>SoleData.computeunivariatefeature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">computeunivariatefeature(f::AbstractUnivariateFeature, varchannel; kwargs...)</code></pre><p>Compute a feature on a variable channel (i.e., world reading) of an instance.</p><p>See also <a href="#SoleData.AbstractUnivariateFeature"><code>AbstractUnivariateFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L111-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.featvaltype-Tuple{Any, VarFeature}"><a class="docstring-binding" href="#SoleData.featvaltype-Tuple{Any, VarFeature}"><code>SoleData.featvaltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">featvaltype(dataset, f::VarFeature)</code></pre><p>Return the type of the values returned by feature <code>f</code> on logiseed <code>dataset</code>.</p><p>See also <a href="#SoleData.VarFeature"><code>VarFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L42-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.parsefeature-Union{Tuple{FT}, Tuple{Type{FT}, AbstractString}} where FT&lt;:VarFeature"><a class="docstring-binding" href="#SoleData.parsefeature-Union{Tuple{FT}, Tuple{Type{FT}, AbstractString}} where FT&lt;:VarFeature"><code>SoleData.parsefeature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parsefeature(FT::Type{&lt;:VarFeature}, expr::AbstractString; kwargs...)</code></pre><p>Parse a <a href="#SoleData.VarFeature"><code>VarFeature</code></a> of type <code>FT</code> from its <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a> representation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>featvaltype::Union{Nothing,Type} = nothing</code>: the feature&#39;s featvaltype   (recommended for some features, e.g., <a href="#SoleData.UnivariateFeature"><code>UnivariateFeature</code></a>);</li><li><code>opening_parenthesis::String = &quot;[&quot;</code>:   the string signaling the opening of an expression block (e.g., <code>&quot;min[V2]&quot;</code>);</li><li><code>closing_parenthesis::String = &quot;]&quot;</code>:   the string signaling the closing of an expression block (e.g., <code>&quot;min[V2]&quot;</code>);</li><li><code>additional_feature_aliases = Dict{String,Base.Callable}()</code>: A dictionary mapping strings to   callables, useful when parsing custom-made, non-standard features.   By default, features such as &quot;avg&quot; or &quot;min&quot; are provided for   (see <code>SoleData.BASE_FEATURE_FUNCTIONS_ALIASES</code>);   note that, in case of clashing <code>string</code>s,   the provided additional aliases will override the standard ones;</li><li><code>variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing</code>:   mapping from variable name to variable index, useful when parsing from   <code>syntaxstring</code>s with variable names (e.g., <code>&quot;min[Heart rate]&quot;</code>);</li><li><code>variable_name_prefix::String = &quot;V&quot;</code>:   prefix used with variable indices (e.g., &quot;V10&quot;).</li></ul><p>Note that at most one argument in <code>variable_names_map</code> and <code>variable_name_prefix</code> should be provided.</p><div class="admonition is-info" id="Note-a94d7e5ed972599f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a94d7e5ed972599f" title="Permalink"></a></header><div class="admonition-body"><p>The default parentheses, here, differ from those of <a href="@ref"><code>SoleLogics.parseformula</code></a>, since features are typically wrapped into <code>Atom</code>s, and <code>parseformula</code> does not allow parenthesis characters in atoms&#39; <code>syntaxstring</code>s.</p></div></div><p>See also <a href="#SoleData.VarFeature"><code>VarFeature</code></a>, <a href="#SoleData.featvaltype-Tuple{Any, VarFeature}"><code>featvaltype</code></a>, <a href="#SoleData.parsecondition-Tuple{Type{&lt;:SoleData.AbstractCondition}, AbstractString}"><code>parsecondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L613-L646">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.variable_name-Tuple{SoleData.AbstractUnivariateFeature}"><a class="docstring-binding" href="#SoleData.variable_name-Tuple{SoleData.AbstractUnivariateFeature}"><code>SoleData.variable_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variable_name(
    f::AbstractUnivariateFeature;
    variable_names_map::Union{Nothing,AbstractDict,AbstractVector} = nothing,
    variable_name_prefix::Union{Nothing,String} = &quot;V&quot;,
)::String</code></pre><p>Return the name of the variable targeted by a univariate feature. By default, an variable name is a number prefixed by &quot;V&quot;; however, <code>variable_names_map</code> or <code>variable_name_prefix</code> can be used to customize variable names. The prefix can be customized by specifying <code>variable_name_prefix</code>. Alternatively, a mapping from string to integer (either via a Dictionary or a Vector) can be passed as <code>variable_names_map</code>. Note that only one in <code>variable_names_map</code> and <code>variable_name_prefix</code> should be provided.</p><p>See also <a href="#SoleData.parsecondition-Tuple{Type{&lt;:SoleData.AbstractCondition}, AbstractString}"><code>parsecondition</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleLogics.syntaxstring"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/var-features.jl#L128-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.Aggregator"><a class="docstring-binding" href="#SoleData.Aggregator"><code>SoleData.Aggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const Aggregator = Function</code></pre><p>A test operator is a binary Julia <code>Function</code> used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <code>&lt;</code>, <code>&gt;</code>, <code>≥</code>, <code>≤</code>, <code>!=</code>, and <code>==</code> are typically used.</p><p>See also <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleData.ScalarOneStepMemoset"><code>ScalarOneStepMemoset</code></a>, <a href="#SoleData.TestOperator"><code>TestOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/test-operators.jl#L27-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.TestOperator"><a class="docstring-binding" href="#SoleData.TestOperator"><code>SoleData.TestOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const TestOperator = Function</code></pre><p>A test operator is a binary Julia <code>Function</code> used for comparing a feature value and a threshold. In a crisp (i.e., boolean, non-fuzzy) setting, the test operator returns a Boolean value, and <code>&lt;</code>, <code>&gt;</code>, <code>≥</code>, <code>≤</code>, <code>!=</code>, and <code>==</code> are typically used.</p><p>See also <a href="#SoleData.Aggregator"><code>Aggregator</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/test-operators.jl#L2-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}"><a class="docstring-binding" href="#SoleData.apply_test_operator-Union{Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1, T2}"><code>SoleData.apply_test_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply a test operator by simply passing the feature value and threshold to the (binary) test operator function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/test-operators.jl#L15-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ObliqueScalarCondition"><a class="docstring-binding" href="#SoleData.ObliqueScalarCondition"><code>SoleData.ObliqueScalarCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObliqueScalarCondition(features, b, u, test_operator)</code></pre><p>An oblique scalar condition (see <em>oblique decision trees</em>), such as <span>$((features - b) ⋅ u) ≥ 0$</span>, where <code>features</code> is a set of <span>$m$</span> features, and <span>$b,u ∈ ℝ^m$</span>.</p><p>See also <a href="@ref"><code>AbstractScalarCondition</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L557-L567">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.RangeScalarCondition"><a class="docstring-binding" href="#SoleData.RangeScalarCondition"><code>SoleData.RangeScalarCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RangeScalarCondition{U&lt;:Number,FT&lt;:AbstractFeature} &lt;: AbstractScalarCondition{FT}</code></pre><p>A condition specifying a range of values for a scalar feature.</p><p>Fields:</p><ul><li><code>feature</code>: the scalar feature</li><li><code>minval</code>, <code>maxval</code>: the minimum and maximum values of the range</li><li><code>minincluded</code>, <code>maxincluded</code>: whether to include the minimum and maximum values in the range, respectively</li></ul><p>The range is specified using interval notation, where the minimum value is included if <code>minincluded</code> is <code>true</code> and excluded if it is <code>false</code>. Similarly, the maximum value is included if <code>maxincluded</code> is <code>true</code> and excluded if it is <code>false</code>.</p><p>For example, if <code>minincluded == true</code> and <code>maxincluded == false</code>, the range is <code>[minval, maxval)</code>.</p><p>The <code>checkcondition</code> method checks whether the value of the feature is within the specified range.</p><p>The <code>syntaxstring</code> method returns a string representation of the condition in the form <code>feature ∈ [minval, maxval]</code>, where the interval notation is used to indicate whether the minimum and maximum values are included or excluded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L595-L616">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarCondition"><a class="docstring-binding" href="#SoleData.ScalarCondition"><code>SoleData.ScalarCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ScalarCondition{U,FT&lt;:AbstractFeature,M&lt;:ScalarMetaCondition{FT}} &lt;: AbstractScalarCondition{FT}
    metacond::M
    a::U
end</code></pre><p>A scalar condition comparing a computed feature value (see <code>ScalarMetaCondition</code>) and a threshold value <code>a</code>. It can be evaluated on a world of an instance of a logical dataset.</p><p>For example: <span>$min[V1] ≥ 10$</span>, which translates to &quot;Within this world, the minimum of variable 1 is greater or equal than 10.&quot; In this case, the feature a <a href="#SoleData.VariableMin"><code>VariableMin</code></a> object.</p><p>See also <a href="@ref"><code>AbstractScalarCondition</code></a>, <a href="#SoleData.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L179-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarMetaCondition"><a class="docstring-binding" href="#SoleData.ScalarMetaCondition"><code>SoleData.ScalarMetaCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ScalarMetaCondition{FT&lt;:AbstractFeature,O&lt;:TestOperator} &lt;: AbstractScalarCondition{FT}
    feature::FT
    test_operator::O
end</code></pre><p>A metacondition representing a scalar comparison method. Here, the <code>feature</code> is a scalar function that can be computed on a world of an instance of a logical dataset. A test operator is a binary mathematical relation, comparing the computed feature value and an external threshold value (see <code>ScalarCondition</code>). A metacondition can also be used for representing the infinite set of conditions that arise with a free threshold (see <code>UnboundedScalarAlphabet</code>): <span>${min[V1] ≥ a, a ∈ ℝ}$</span>.</p><p>See also <a href="@ref"><code>AbstractScalarCondition</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L71-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.UnivariateScalarAlphabet"><a class="docstring-binding" href="#SoleData.UnivariateScalarAlphabet"><code>SoleData.UnivariateScalarAlphabet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct UnivariateScalarAlphabet &lt;: AbstractAlphabet{ScalarCondition}
    featcondition::Tuple{ScalarMetaCondition,Vector}
end</code></pre><p>A finite alphabet of conditions, grouped by (a finite set of) metaconditions.</p><p>See also <a href="@ref"><code>UnboundedScalarAlphabet</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleData.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L458-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.syntaxstring-Tuple{ScalarCondition}"><a class="docstring-binding" href="#SoleLogics.syntaxstring-Tuple{ScalarCondition}"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">syntaxstring(m::ScalarCondition; 
            style=false, removewhitespaces::Bool=false, 
            pretty_op::Bool=true, kwargs...)::String</code></pre><p>Generate a formatted string representation of a feature, test operator and threshold combination.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>threshold_digits::Union{Nothing,Integer}=nothing</code>: If set, rounds the threshold value to the specified number of digits (via <code>round(...; digits=threshold_digits)</code>).</li><li><code>threshold_display_method::Union{Nothing,Base.Callable}=nothing</code>: A function applied to the threshold value before string conversion. If provided, it takes precedence over <code>threshold_digits</code>.</li><li><code>style::Union{Bool,Dict}=false</code>: Style options for formatting. If a dict with key  <code>:featurestyle</code> is provided, applies styling (<code>:bold</code> supported). Default <code>false</code> means no styling.</li><li><code>removewhitespaces::Bool=false</code>: If <code>true</code>, removes spaces between feature, operator and threshold.  Useful for generating output suitable for PLA (Programmable Logic Array) applications. Default is <code>false</code> (includes space).</li><li><code>kwargs...</code>: Additional keyword arguments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/conditions.jl#L299-L317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarExistentialFormula"><a class="docstring-binding" href="#SoleData.ScalarExistentialFormula"><code>SoleData.ScalarExistentialFormula</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Templated formula for ⟨R⟩ f ⋈ t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/templated-formulas.jl#L40-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarFormula"><a class="docstring-binding" href="#SoleData.ScalarFormula"><code>SoleData.ScalarFormula</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for templated formulas on scalar conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/templated-formulas.jl#L7-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarUniversalFormula"><a class="docstring-binding" href="#SoleData.ScalarUniversalFormula"><code>SoleData.ScalarUniversalFormula</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Templated formula for [R] f ⋈ t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/templated-formulas.jl#L102-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.featvalue-Tuple{AbstractFeature, Any, Integer, Any}"><a class="docstring-binding" href="#SoleData.featvalue-Tuple{AbstractFeature, Any, Integer, Any}"><code>SoleData.featvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">featvalue(feature, logiseed, i_instance, w)</code></pre><p>Return the value of a feature at world on an instance of a logiset.</p><p>See <a href="#SoleData.islogiseed-Tuple{Any}"><code>islogiseed</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/logiseed.jl#L85-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.islogiseed-Tuple{Any}"><a class="docstring-binding" href="#SoleData.islogiseed-Tuple{Any}"><code>SoleData.islogiseed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">islogiseed(dataset)::Bool</code></pre><p>A logiseed is a dataset that can be converted to a logiset (e.g., via <a href="#SoleData.scalarlogiset"><code>scalarlogiset</code></a>). If the <code>dataset</code> is a unimodal logiseed, the following methods should be defined:</p><pre><code class="language-julia hljs">    islogiseed(::typeof(dataset)) = true
    initlogiset(dataset, features; kwargs...)
    ninstances(dataset)
    nvariables(dataset)
    frame(dataset, i_instance::Integer)
    featvalue(feature::VarFeature, dataset, i_instance::Integer, w::AbstractWorld)
    varnames(dataset)::Union{Nothing,Vector{&lt;:Union{Integer, Symbol}}}
    vareltype(dataset, i_variable::Union{Integer, Symbol})</code></pre><p>If <code>dataset</code> is a multimodal logiseed, the following methods should be defined, while its modalities (iterated via <code>eachmodality</code>) should provide the methods above:</p><pre><code class="language-julia hljs">    ismultilogiseed(::typeof(dataset)) = true
    nmodalities(logiseed)
    eachmodality(logiseed)</code></pre><p><strong>Examples</strong></p><p><strong>A DataFrame</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFrames; df = DataFrame(rand(150, 4), :auto);


julia&gt; SoleData.islogiseed(df)
true

julia&gt; ninstances(df), nvariables(df)
(150, 4)

julia&gt; SoleData.varnames(df)
4-element Vector{String}:
 &quot;x1&quot;
 &quot;x2&quot;
 &quot;x3&quot;
 &quot;x4&quot;
</code></pre><p><strong>A <code>Vector</code> of multidimensional instances (i.e., instances that are <code>Array{Number,N}</code> with <code>N</code> ≥ 1, where the last dimension is that of variables)</strong></p><pre><code class="language-julia hljs">julia&gt; X = [rand(4) for i in 1:150];


julia&gt; SoleData.islogiseed(X)
true

julia&gt; ninstances(X), nvariables(X)
(150, 4)

julia&gt; SoleData.varnames(X)
nothing
</code></pre><p>See also <a href="#SoleData.AbstractLogiset"><code>AbstractLogiset</code></a>, <a href="#SoleData.scalarlogiset"><code>scalarlogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/logiseed.jl#L5-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ismultilogiseed-Tuple{Any}"><a class="docstring-binding" href="#SoleData.ismultilogiseed-Tuple{Any}"><code>SoleData.ismultilogiseed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ismultilogiseed(dataset)::Bool</code></pre><p>See <a href="#SoleData.islogiseed-Tuple{Any}"><code>islogiseed</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/logiseed.jl#L115-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}"><a class="docstring-binding" href="#SoleData.naturalgrouping-Tuple{DataFrames.AbstractDataFrame}"><code>SoleData.naturalgrouping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">naturalgrouping(
    X::AbstractDataFrame;
    allow_variable_drop = false,
)::AbstractVector{&lt;:AbstractVector{&lt;:Symbol}}</code></pre><p>Return variables grouped by their logical nature; the nature of a variable is automatically derived from its type (e.g., Real, Vector{&lt;:Real} or Matrix{&lt;:Real}) and frame. All instances must have the same frame (e.g., channel size/number of worlds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/scalarlogiset.jl#L482-L492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.scalaralphabet-Tuple{SoleLogics.AbstractAlphabet{&lt;:ScalarCondition}, Vararg{Any}}"><a class="docstring-binding" href="#SoleData.scalaralphabet-Tuple{SoleLogics.AbstractAlphabet{&lt;:ScalarCondition}, Vararg{Any}}"><code>SoleData.scalaralphabet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scalaralphabet(a::AbstractAlphabet{&lt;:ScalarCondition}, args...; kwargs...)</code></pre><p><strong>TODO explain args and kwargs...</strong></p><ul><li><code>sorted</code>: whether to sort the atoms in the sub-alphabets (i.e., the threshold domains),   by a truer-first policy (default: true)</li><li><code>test_operators</code>: test operators to use (defaulted to <code>[≤, ≥]</code> for real-valued features, and <code>[(==), (≠)]</code> for other features, e.g., categorical)</li></ul><p>Return a MultivariateScalarAlphabet from an alphabet of <code>ScalarCondition</code>&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/scalarlogiset.jl#L579-L590">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.scalarlogiset"><a class="docstring-binding" href="#SoleData.scalarlogiset"><code>SoleData.scalarlogiset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">scalarlogiset(dataset, features; kwargs...)</code></pre><p>Convert a dataset structure (with variables) to a logiset with scalar-valued features. Refer to <a href="#SoleData.islogiseed-Tuple{Any}"><code>islogiseed</code></a> for the interface that <code>dataset</code> must adhere to.</p><p><strong>Arguments</strong></p><ul><li><code>dataset</code>: the dataset that will be transformed into a logiset. It should adhere to the <a href="#SoleData.islogiseed-Tuple{Any}"><code>islogiseed</code></a> interface;</li><li><code>features</code>: vector of features, corresponding to <code>dataset</code> columns;</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>use_onestep_memoization::Union{Bool,Type{&lt;:AbstractOneStepMemoset}}=!isnothing(conditions) &amp;&amp; !isnothing(relations)</code>:</li></ul><p>enable one-step memoization, optimizing the checking of specific, short formulas using specific scalar conditions and relations (see <a href="#SoleData.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>);</p><ul><li><code>conditions::Union{Nothing,AbstractVector{&lt;:AbstractCondition}}=nothing</code>:</li></ul><p>a set of conditions or metaconditions to be used in one-step memoization. If not provided, metaconditions given by minimum and maximum applied to each variable will be used (see <a href="#SoleData.ScalarMetaCondition"><code>ScalarMetaCondition</code></a>);</p><ul><li><code>relations::Union{Nothing,AbstractVector{&lt;:AbstractRelation}}=nothing</code>:</li></ul><p>a set of relations to be used in one-step memoization (see <a href="@ref"><code>AbstractRelation</code></a>);</p><ul><li><code>onestep_precompute_globmemoset::Bool = (use_onestep_memoization != false)</code>:</li></ul><p>precompute the memoization set for global one-step formulas. This usually takes little time: in facto, because, global formulas are grounded, the intermediate <code>check</code> result does not depend on the number of worlds.</p><ul><li><code>onestep_precompute_relmemoset::Bool = false</code>:</li></ul><p>precompute the memoization set for global one-step formulas. This may take a long time, depending on the relations and the number of worlds; it is usually not needed.</p><ul><li><code>use_full_memoization::Union{Bool,Type{&lt;:Union{AbstractOneStepMemoset,AbstractFullMemoset}}}=true</code>:</li></ul><p>enable full memoization, where every intermediate <code>check</code> result is cached to avoid recomputing. This can be used in conjunction with one-step memoization;</p><ul><li><code>print_progress::Bool = false</code>: print a progress bar;</li><li><code>allow_propositional::Bool = false</code>: allows a tabular (i.e, non-relational) dataset to be instantiated as a <code>PropositionalLogiset</code>, instead of a modal logiset;</li><li><code>force_i_variables::Bool = false</code>: when conditions are to be inferred (<code>conditions = nothing</code>), force (meta)conditions to refer to variables by their integer index, instead of their <code>Symbol</code> name (when available through <code>varnames</code>, see <a href="#SoleData.islogiseed-Tuple{Any}"><code>islogiseed</code></a>).</li></ul><p><strong>Logiseed-specific Keyword Arguments</strong></p><ul><li><code>worldtype_by_dim::AbstractDict{&lt;:Integer,&lt;:Type} = Dict([0 =&gt; OneWorld, 1 =&gt; Interval, 2 =&gt; Interval2D])</code>:</li></ul><p>When the dataset is a <a href="@ref"><code>MultiData.AbstractDimensionalDataset</code></a>, this map between the <a href="@ref"><code>dimensionality</code></a> and the desired <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a> type is used to infer the frame type. By default, dimensional datasets of dimensionalities 0, 1 and 2 will generate logisets based on OneWorld, Interval&#39;s, and Interval2D&#39;s, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(A = [36, 37, 38], B = [1, 2, 3])
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │    36      1
   2 │    37      2
   3 │    38      3

julia&gt; scalarlogiset(df; worldtype_by_dim=([0=&gt;OneWorld]))
SupportedLogiset with 1 support (2.21 KBs)
├ worldtype:                   OneWorld
├ featvaltype:                 Int64
├ featuretype:                 VariableValue
├ frametype:                   SoleLogics.FullDimensionalFrame{0, OneWorld}
├ # instances:                 3
├ usesfullmemo:                true
├[BASE] UniformFullDimensionalLogiset of dimensionality 0 (688.0 Bytes)
│ ├ size × eltype:              (3, 2) × Int64
│ └ features:                   2 -&gt; VariableValue[V1, V2]
└[SUPPORT 1] FullMemoset (0 memoized values, 1.5 KBs))</code></pre><p>julia&gt; pointlogiset = scalarlogiset(     X<em>df;     worldtype</em>by_dim=Dict([1 =&gt; SoleLogics.Point1D, 2 =&gt; SoleLogics.Point2D]) )</p><p>See also <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>, <a href="#SoleData.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>, <code>SoleLogics.AbstractRelation</code>, <code>SoleLogics.AbstractWorld</code>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleData.VarFeature"><code>VarFeature</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/scalarlogiset.jl#L4-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.AbstractScalarOneStepGlobalMemoset"><a class="docstring-binding" href="#SoleData.AbstractScalarOneStepGlobalMemoset"><code>SoleData.AbstractScalarOneStepGlobalMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for one-step memoization structure for checking &quot;global&quot; formulas of type <code>⟨G⟩ (f ⋈ t)</code>.     We refer to these structures as <em>global memosets</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/onestep-memoset.jl#L129-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.ScalarOneStepRelationalMemoset"><a class="docstring-binding" href="#SoleData.ScalarOneStepRelationalMemoset"><code>SoleData.ScalarOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A generic, one-step memoization structure used for checking specific formulas of scalar conditions on datasets with scalar features. The formulas are of type ⟨R⟩ (f ⋈ t)</p><p>See also <a href="#SoleData.AbstractScalarOneStepRelationalMemoset"><code>AbstractScalarOneStepRelationalMemoset</code></a>, <a href="#SoleData.FullMemoset"><code>FullMemoset</code></a>, <a href="#SoleData.SupportedLogiset"><code>SupportedLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/onestep-memoset.jl#L600-L609">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.PropositionalLogiset"><a class="docstring-binding" href="#SoleData.PropositionalLogiset"><code>SoleData.PropositionalLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PropositionalLogiset(table) &lt;: AbstractPropositionalLogiset</code></pre><p>A logiset of propositional interpretations, wrapping a <a href="https://github.com/JuliaData/Tables.jl">Tables</a>&#39; table of real/string/categorical values.</p><p><strong>Examples</strong></p><p>This structure can be used to check propositional formulas:</p><pre><code class="language-julia hljs">using SoleData, MLJBase

X = PropositionalLogiset(MLJBase.load_iris())

φ = parseformula(
    &quot;sepal_length &gt; 5.8 ∧ sepal_width &lt; 3.0 ∨ target == &quot;setosa&quot;&quot;;
    atom_parser = a-&gt;Atom(parsecondition(SoleData.ScalarCondition, a; featuretype = SoleData.VariableValue))
)

check(φ, X, 10) # Check the formula on a single instance

satmask = check(φ, X) # Check the formula on the whole dataset

slicedataset(X, satmask)
slicedataset(X, (!).(satmask))</code></pre><p>See also <a href="#SoleData.AbstractLogiset"><code>AbstractLogiset</code></a>, <a href="@ref"><code>AbstractAssignment</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/propositional-logiset.jl#L14-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.alphabet"><a class="docstring-binding" href="#SoleLogics.alphabet"><code>SoleLogics.alphabet</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alphabet(
    X::PropositionalLogiset,
    sorted=true;
    test_operators::Union{Nothing,AbstractVector{&lt;:TestOperator},Base.Callable}=nothing,
    discretizedomain=false,
    y::Union{Nothing, AbstractVector}=nothing,
)::MultivariateScalarAlphabet</code></pre><p>Constructs an alphabet based on the provided <code>PropositionalLogiset</code> <code>X</code>, with optional parameters:</p><ul><li><code>sorted</code>: whether to sort the atoms in the sub-alphabets (i.e., the threshold domains),   by a truer-first policy (default: true)</li><li><code>test_operators</code>: test operators to use (defaulted to <code>[≤, ≥]</code> for real-valued features, and <code>[(==), (≠)]</code> for other features, e.g., categorical)</li><li><code>discretizedomain</code>: whether to discretize the domain (default: false)</li><li><code>y</code>: vector used for discretization (required if <code>discretizedomain</code> is true)</li></ul><p>Returns a <code>UnionAlphabet</code> containing <code>ScalarCondition</code> and <code>UnivariateScalarAlphabet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/scalar/propositional-logiset.jl#L192-L209">source</a></section></details></article><h3 id="Scalar-Dimensional-Logisets"><a class="docs-heading-anchor" href="#Scalar-Dimensional-Logisets">Scalar Dimensional Logisets</a><a id="Scalar-Dimensional-Logisets-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Dimensional-Logisets" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><a class="docstring-binding" href="#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><code>SoleData.DimensionalDatasets.UniformFullDimensionalLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct UniformFullDimensionalLogiset{
    U,
    W&lt;:AbstractWorld,
    N,
    D&lt;:AbstractArray{U},
    FT&lt;:AbstractFeature,
    FR&lt;:FullDimensionalFrame{N,W},
} &lt;: AbstractUniformFullDimensionalLogiset{U,N,W,FT,FR}</code></pre><p>Uniform scalar logiset with full dimensional frames of dimensionality <code>N</code>, storing values for each world in a <code>ninstances</code> × <code>nfeatures</code> array.</p><p>The size of the internal structure (or <code>featstruct</code>) depends on the (unique) world type considered.</p><p><strong>Examples</strong></p><p><strong>Interval-based frames</strong></p><p>With an interval-based, <code>N</code>-dimensional frame, the worlds are <code>N</code>-intervals, and have <code>2*N</code> parameters, which are used to index an <code>(N*2+2)</code>-dimensional <code>featstruct</code> (recall that two dimensions are reserved for instances and features).</p><p>For example, consider the case of a 1-dimensional frame with three points:         1       2       3     ─────────────────────────</p><p>Given an instance and a feature, the <code>featstruct</code> will map the hyper-intervals across two dimensions: ┌───┬───────┬───────┬───────┐ │   │   1   │   2   │   3   │ ├───┼───────┼───────┼───────┤ │ 1 │ [1,1] │ [1,2] │ [1,3] │ ├───┼───────┼───────┼───────┤ │ 2 │       │ [2,2] │ [2,3] │ ├───┼───────┼───────┼───────┤ │ 3 │       │       │ [3,3] │ └───┴───────┴───────┴───────┘</p><p>See also <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>, <a href="@ref"><code>AbstractUniformFullDimensionalLogiset</code></a>, <code>SoleLogics.FullDimensionalFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/dimensional-structures/logiset.jl#L7-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset"><a class="docstring-binding" href="#SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset"><code>SoleData.DimensionalDatasets.UniformFullDimensionalOneStepRelationalMemoset</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A relational memoset optimized for uniform scalar logisets with full dimensional frames of dimensionality <code>N</code>, storing values for each world in a <code>ninstances</code> × <code>nmetaconditions</code> × <code>nrelations</code> array. Each world is a hyper-interval, and its <code>N*2</code> components are used to index different array dimensions, ultimately resulting in a <code>(N*2+3)</code>-dimensional array.</p><p>See also <a href="#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><code>UniformFullDimensionalLogiset</code></a>, <a href="@ref"><code>FullDimensionalFrame</code></a>, <a href="#SoleData.AbstractModalLogiset"><code>AbstractModalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/dimensional-structures/onestep-memosets.jl#L5-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.computeunivariatefeature-Union{Tuple{T}, Tuple{VariableDistance, AbstractArray{T}}} where T"><a class="docstring-binding" href="#SoleData.computeunivariatefeature-Union{Tuple{T}, Tuple{VariableDistance, AbstractArray{T}}} where T"><code>SoleData.computeunivariatefeature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function computeunivariatefeature(
    f::VariableDistance,
    varchannel::AbstractArray{T};
    aggregator::Function=minimum
) where {T}</code></pre><p>Return <code>aggregator( [distance(f)(r, varchannel) for r in references(f)] )</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/dimensional-structures/computefeature.jl#L46-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.initlogiset-Tuple{AbstractVector{&lt;:AbstractArray{T, D}} where {T&lt;:Number, D}, AbstractVector}"><a class="docstring-binding" href="#SoleData.initlogiset-Tuple{AbstractVector{&lt;:AbstractArray{T, D}} where {T&lt;:Number, D}, AbstractVector}"><code>SoleData.initlogiset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function initlogiset(
    dataset::AbstractDimensionalDataset,
    features::AbstractVector;
    worldtype_by_dim::Union{Nothing,AbstractDict{&lt;:Integer,&lt;:Type}}=nothing
)::UniformFullDimensionalLogiset</code></pre><p>Given an <a href="@ref"><code>AbstractDimensionalDataset</code></a>, build a <a href="#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><code>UniformFullDimensionalLogiset</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li>worldtype<em>by</em>dim::Union{Nothing,AbstractDict{&lt;:Integer,&lt;:Type}}=nothing:</li></ul><p>map between a dimensionality, as integer, and the <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a> type associated; when unspecified, this is defaulted to <code>Dict(0 =&gt; OneWorld, 1 =&gt; Interval, 2 =&gt; Interval2D)</code>.</p><p>See also <a href="@ref"><code>AbstractDimensionalDataset</code></a>, SoleLogics.AbstractWorld, MultiData.dimensionality, <a href="#SoleData.DimensionalDatasets.UniformFullDimensionalLogiset"><code>UniformFullDimensionalLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/dimensional-structures/logiseeds/abstractdimensionaldataset.jl#L21-L40">source</a></section></details></article><h2 id="Multimodal-Logisets"><a class="docs-heading-anchor" href="#Multimodal-Logisets">Multimodal Logisets</a><a id="Multimodal-Logisets-1"></a><a class="docs-heading-anchor-permalink" href="#Multimodal-Logisets" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleData.MultiFormula"><a class="docstring-binding" href="#SoleData.MultiFormula"><code>SoleData.MultiFormula</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MultiFormula{F&lt;:Formula} &lt;: AbstractSyntaxStructure
    modforms::Dict{Int,F}
end</code></pre><p>A logical formula that can be checked on a <code>MultiLogiset</code>, representing the logical and between formulas across different modalities.</p><p>See also <a href="#SoleData.MultiLogiset"><code>MultiLogiset</code></a>, <a href="@ref"><code>eachmodality</code></a>, <a href="@ref"><code>nmodalities</code></a>, <a href="#SoleData.modforms-Tuple{MultiFormula}"><code>modforms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/multilogiset.jl#L185-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.MultiLogiset"><a class="docstring-binding" href="#SoleData.MultiLogiset"><code>SoleData.MultiLogiset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MultiLogiset{L&lt;:AbstractLogiset}
    modalities  :: Vector{L}
end</code></pre><p>A logical dataset composed of different <a href="https://en.wikipedia.org/wiki/Multimodal_learning">modalities</a>); this structure is useful for representing multimodal datasets in logical terms.</p><p>See also <a href="#SoleData.AbstractLogiset"><code>AbstractLogiset</code></a>, <a href="#SoleData.minify"><code>minify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/multilogiset.jl#L7-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleData.modforms-Tuple{MultiFormula}"><a class="docstring-binding" href="#SoleData.modforms-Tuple{MultiFormula}"><code>SoleData.modforms</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return a dictionary associating different formulas to different dataset modalities. </p><p>See also <a href="#SoleData.MultiFormula"><code>MultiFormula</code></a>, <a href="#SoleData.MultiLogiset"><code>MultiLogiset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/utils/multilogiset.jl#L207-L211">source</a></section></details></article><p>&lt;!– ## MLJ Integration</p><p>–&gt;</p><h1 id="Optimizations"><a class="docs-heading-anchor" href="#Optimizations">Optimizations</a><a id="Optimizations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizations" title="Permalink"></a></h1><h2 id="Representatives"><a class="docs-heading-anchor" href="#Representatives">Representatives</a><a id="Representatives-1"></a><a class="docs-heading-anchor-permalink" href="#Representatives" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleData.representatives-Union{Tuple{W}, Tuple{AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W&lt;:AbstractWorld"><a class="docstring-binding" href="#SoleData.representatives-Union{Tuple{W}, Tuple{AbstractFrame{W}, W, AbstractRelation, SoleData.AbstractCondition}} where W&lt;:AbstractWorld"><code>SoleData.representatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">representatives(
    fr::AbstractFrame{W},
    S::W,
    ::AbstractRelation,
    ::AbstractCondition
) where {W&lt;:AbstractWorld}</code></pre><p>Return an iterator to the (few) <em>representative</em> accessible worlds that are necessary for computing and propagating truth values through existential modal connectives. When this optimization is possible (e.g., when checking specific formulas on scalar conditions), it allows to further boost &quot;one-step&quot; optimizations (see <a href="#SoleData.AbstractOneStepMemoset"><code>AbstractOneStepMemoset</code></a>).</p><p>For example, consider a Kripke structure with a 1-dimensional <code>FullDimensionalFrame</code> of length 100, and the problem of checking a formula &quot;⟨L⟩(max[V1] ≥ 10)&quot; on a <a href="#SoleLogics.Interval"><code>SoleLogics.Interval</code></a> <code>SoleLogics.Interval{Int64}(1, 2)</code> (with <code>L</code> being Allen&#39;s &quot;Later&quot; relation, see <a href="#SoleLogics.IA_L"><code>SoleLogics.IA_L</code></a>). Comparing 10 with the (maximum) &quot;max[V1]&quot; computed on all worlds is the naïve strategy to check the formula. However, in this case, comparing 10 to the &quot;max[V1]&quot; computed on the single <code>Interval</code> SoleLogics.Interval{Int64}(2, 101) suffice to establish whether the structure satisfies the formula. Similar cases arise depending on the relation, feature and test operator (or, better, its <em>aggregator</em>).</p><p>Note that this method fallsback to <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.accessibles"><code>SoleLogics.accessibles</code></a>, <a href="#SoleData.ScalarCondition"><code>ScalarCondition</code></a>, <a href="#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleData.jl/blob/02dd8e04bd03bc83a863e651212964277e1991e5/src/types/representatives.jl#L5-L38">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 15:11">Friday 13 February 2026</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
